// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/admin_api.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/flowup/headlessapis/go-sdk/common/v1"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type OrderStatus int32

const (
	ORDER_STATUS_UNDEFINED OrderStatus = 0
	NOT_SUBMITTED          OrderStatus = 1
	SUBMITTED              OrderStatus = 2
	PAID                   OrderStatus = 3
	SENT                   OrderStatus = 4
	CANCEL                 OrderStatus = 5
)

var OrderStatus_name = map[int32]string{
	0: "ORDER_STATUS_UNDEFINED",
	1: "NOT_SUBMITTED",
	2: "SUBMITTED",
	3: "PAID",
	4: "SENT",
	5: "CANCEL",
}

var OrderStatus_value = map[string]int32{
	"ORDER_STATUS_UNDEFINED": 0,
	"NOT_SUBMITTED":          1,
	"SUBMITTED":              2,
	"PAID":                   3,
	"SENT":                   4,
	"CANCEL":                 5,
}

func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{0}
}

type Merchant struct {
	// [Required] merchantId can be set only once and is unchangeable during lifetime
	MerchantId string `protobuf:"bytes,1,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	// [Required] name of the merchant can be customized by the user, however, the id
	// will stay unchanged
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Merchant) Reset()      { *m = Merchant{} }
func (*Merchant) ProtoMessage() {}
func (*Merchant) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{0}
}
func (m *Merchant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merchant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merchant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merchant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merchant.Merge(m, src)
}
func (m *Merchant) XXX_Size() int {
	return m.Size()
}
func (m *Merchant) XXX_DiscardUnknown() {
	xxx_messageInfo_Merchant.DiscardUnknown(m)
}

var xxx_messageInfo_Merchant proto.InternalMessageInfo

func (m *Merchant) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Merchant) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MerchantList struct {
	Items []*Merchant `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *MerchantList) Reset()      { *m = MerchantList{} }
func (*MerchantList) ProtoMessage() {}
func (*MerchantList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{1}
}
func (m *MerchantList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerchantList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerchantList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerchantList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerchantList.Merge(m, src)
}
func (m *MerchantList) XXX_Size() int {
	return m.Size()
}
func (m *MerchantList) XXX_DiscardUnknown() {
	xxx_messageInfo_MerchantList.DiscardUnknown(m)
}

var xxx_messageInfo_MerchantList proto.InternalMessageInfo

func (m *MerchantList) GetItems() []*Merchant {
	if m != nil {
		return m.Items
	}
	return nil
}

type User struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Email string `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	// id of the user this user was invited by into the system
	InvitedById string `protobuf:"bytes,5,opt,name=invitedById,proto3" json:"invitedById,omitempty"`
	MerchantId  string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	Thumbnail   string `protobuf:"bytes,50,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *User) Reset()      { *m = User{} }
func (*User) ProtoMessage() {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{2}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetInvitedById() string {
	if m != nil {
		return m.InvitedById
	}
	return ""
}

func (m *User) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *User) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

type UserList struct {
	Items []*User `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *UserList) Reset()      { *m = UserList{} }
func (*UserList) ProtoMessage() {}
func (*UserList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{3}
}
func (m *UserList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserList.Merge(m, src)
}
func (m *UserList) XXX_Size() int {
	return m.Size()
}
func (m *UserList) XXX_DiscardUnknown() {
	xxx_messageInfo_UserList.DiscardUnknown(m)
}

var xxx_messageInfo_UserList proto.InternalMessageInfo

func (m *UserList) GetItems() []*User {
	if m != nil {
		return m.Items
	}
	return nil
}

type Store struct {
	StoreId  string `protobuf:"bytes,1,opt,name=storeId,proto3" json:"storeId,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Location string `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
	// [Required] reference to the merchant id
	MerchantId string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
}

func (m *Store) Reset()      { *m = Store{} }
func (*Store) ProtoMessage() {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{4}
}
func (m *Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return m.Size()
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *Store) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Store) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type StoreList struct {
	Items []*Store `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *StoreList) Reset()      { *m = StoreList{} }
func (*StoreList) ProtoMessage() {}
func (*StoreList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{5}
}
func (m *StoreList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreList.Merge(m, src)
}
func (m *StoreList) XXX_Size() int {
	return m.Size()
}
func (m *StoreList) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreList.DiscardUnknown(m)
}

var xxx_messageInfo_StoreList proto.InternalMessageInfo

func (m *StoreList) GetItems() []*Store {
	if m != nil {
		return m.Items
	}
	return nil
}

type ProductSchema struct {
	ProductSchemaId string `protobuf:"bytes,1,opt,name=productSchemaId,proto3" json:"productSchemaId,omitempty"`
	Name            string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// createdBy is a reference to the user that created this product schema
	CreatedBy  *User             `protobuf:"bytes,3,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	MerchantId string            `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	Labels     map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,100,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProductSchema) Reset()      { *m = ProductSchema{} }
func (*ProductSchema) ProtoMessage() {}
func (*ProductSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{6}
}
func (m *ProductSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductSchema.Merge(m, src)
}
func (m *ProductSchema) XXX_Size() int {
	return m.Size()
}
func (m *ProductSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductSchema.DiscardUnknown(m)
}

var xxx_messageInfo_ProductSchema proto.InternalMessageInfo

func (m *ProductSchema) GetProductSchemaId() string {
	if m != nil {
		return m.ProductSchemaId
	}
	return ""
}

func (m *ProductSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductSchema) GetCreatedBy() *User {
	if m != nil {
		return m.CreatedBy
	}
	return nil
}

func (m *ProductSchema) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *ProductSchema) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ProductSchema) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Product struct {
	ProductId     string            `protobuf:"bytes,1,opt,name=productId,proto3" json:"productId,omitempty"`
	ProductSchema *ProductSchema    `protobuf:"bytes,2,opt,name=productSchema,proto3" json:"productSchema,omitempty"`
	MerchantId    string            `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	StoreIds      []string          `protobuf:"bytes,11,rep,name=storeIds,proto3" json:"storeIds,omitempty"`
	ProviderId    string            `protobuf:"bytes,12,opt,name=providerId,proto3" json:"providerId,omitempty"`
	Name          string            `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	Description   string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	DefaultAmount *v1.Amount        `protobuf:"bytes,15,opt,name=defaultAmount,proto3" json:"defaultAmount,omitempty"`
	Images        []string          `protobuf:"bytes,16,rep,name=images,proto3" json:"images,omitempty"`
	Labels        map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,100,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{7}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Product) GetProductSchema() *ProductSchema {
	if m != nil {
		return m.ProductSchema
	}
	return nil
}

func (m *Product) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Product) GetStoreIds() []string {
	if m != nil {
		return m.StoreIds
	}
	return nil
}

func (m *Product) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetDefaultAmount() *v1.Amount {
	if m != nil {
		return m.DefaultAmount
	}
	return nil
}

func (m *Product) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *Product) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Product) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type UploadMeta struct {
	// [Required] fileName is searchable throughout the system
	FileName string `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	// [Output Only] this is being provided by the system after the file is uploaded
	Link       string            `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	MerchantId string            `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	Labels     map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UploadMeta) Reset()      { *m = UploadMeta{} }
func (*UploadMeta) ProtoMessage() {}
func (*UploadMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{8}
}
func (m *UploadMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadMeta.Merge(m, src)
}
func (m *UploadMeta) XXX_Size() int {
	return m.Size()
}
func (m *UploadMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadMeta.DiscardUnknown(m)
}

var xxx_messageInfo_UploadMeta proto.InternalMessageInfo

func (m *UploadMeta) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadMeta) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *UploadMeta) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *UploadMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Warehouse struct {
}

func (m *Warehouse) Reset()      { *m = Warehouse{} }
func (*Warehouse) ProtoMessage() {}
func (*Warehouse) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{9}
}
func (m *Warehouse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Warehouse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Warehouse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Warehouse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Warehouse.Merge(m, src)
}
func (m *Warehouse) XXX_Size() int {
	return m.Size()
}
func (m *Warehouse) XXX_DiscardUnknown() {
	xxx_messageInfo_Warehouse.DiscardUnknown(m)
}

var xxx_messageInfo_Warehouse proto.InternalMessageInfo

type WarehouseFilter struct {
}

func (m *WarehouseFilter) Reset()      { *m = WarehouseFilter{} }
func (*WarehouseFilter) ProtoMessage() {}
func (*WarehouseFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{10}
}
func (m *WarehouseFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WarehouseFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WarehouseFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WarehouseFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WarehouseFilter.Merge(m, src)
}
func (m *WarehouseFilter) XXX_Size() int {
	return m.Size()
}
func (m *WarehouseFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WarehouseFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WarehouseFilter proto.InternalMessageInfo

type WarehouseList struct {
	Items []*Warehouse `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *WarehouseList) Reset()      { *m = WarehouseList{} }
func (*WarehouseList) ProtoMessage() {}
func (*WarehouseList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{11}
}
func (m *WarehouseList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WarehouseList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WarehouseList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WarehouseList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WarehouseList.Merge(m, src)
}
func (m *WarehouseList) XXX_Size() int {
	return m.Size()
}
func (m *WarehouseList) XXX_DiscardUnknown() {
	xxx_messageInfo_WarehouseList.DiscardUnknown(m)
}

var xxx_messageInfo_WarehouseList proto.InternalMessageInfo

func (m *WarehouseList) GetItems() []*Warehouse {
	if m != nil {
		return m.Items
	}
	return nil
}

type Order struct {
	OrderId     string       `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	Status      OrderStatus  `protobuf:"varint,2,opt,name=status,proto3,enum=admin.v1.OrderStatus" json:"status,omitempty"`
	Note        string       `protobuf:"bytes,3,opt,name=note,proto3" json:"note,omitempty"`
	Items       []*OrderItem `protobuf:"bytes,4,rep,name=items,proto3" json:"items,omitempty"`
	TotalAmount *v1.Amount   `protobuf:"bytes,5,opt,name=totalAmount,proto3" json:"totalAmount,omitempty"`
	CreatedAt   int64        `protobuf:"varint,6,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	MerchantId  string       `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	StoreId     string       `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{12}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return ORDER_STATUS_UNDEFINED
}

func (m *Order) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *Order) GetItems() []*OrderItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Order) GetTotalAmount() *v1.Amount {
	if m != nil {
		return m.TotalAmount
	}
	return nil
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Order) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type OrderItem struct {
	Product *Product   `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	Count   int32      `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Amount  *v1.Amount `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	OrderId string     `protobuf:"bytes,10,opt,name=orderId,proto3" json:"orderId,omitempty"`
}

func (m *OrderItem) Reset()      { *m = OrderItem{} }
func (*OrderItem) ProtoMessage() {}
func (*OrderItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{13}
}
func (m *OrderItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderItem.Merge(m, src)
}
func (m *OrderItem) XXX_Size() int {
	return m.Size()
}
func (m *OrderItem) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderItem.DiscardUnknown(m)
}

var xxx_messageInfo_OrderItem proto.InternalMessageInfo

func (m *OrderItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OrderItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *OrderItem) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *OrderItem) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type OrderList struct {
	Items []*Order `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *OrderList) Reset()      { *m = OrderList{} }
func (*OrderList) ProtoMessage() {}
func (*OrderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{14}
}
func (m *OrderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderList.Merge(m, src)
}
func (m *OrderList) XXX_Size() int {
	return m.Size()
}
func (m *OrderList) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderList.DiscardUnknown(m)
}

var xxx_messageInfo_OrderList proto.InternalMessageInfo

func (m *OrderList) GetItems() []*Order {
	if m != nil {
		return m.Items
	}
	return nil
}

type OrderFilter struct {
	OrderId    string      `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	Status     OrderStatus `protobuf:"varint,2,opt,name=status,proto3,enum=admin.v1.OrderStatus" json:"status,omitempty"`
	MerchantId string      `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
	StoreId    string      `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *OrderFilter) Reset()      { *m = OrderFilter{} }
func (*OrderFilter) ProtoMessage() {}
func (*OrderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{15}
}
func (m *OrderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilter.Merge(m, src)
}
func (m *OrderFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilter proto.InternalMessageInfo

func (m *OrderFilter) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderFilter) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return ORDER_STATUS_UNDEFINED
}

func (m *OrderFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *OrderFilter) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type Provider struct {
	ProviderId string `protobuf:"bytes,1,opt,name=providerId,proto3" json:"providerId,omitempty"`
	MerchantId string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
}

func (m *Provider) Reset()      { *m = Provider{} }
func (*Provider) ProtoMessage() {}
func (*Provider) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{16}
}
func (m *Provider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Provider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Provider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Provider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Provider.Merge(m, src)
}
func (m *Provider) XXX_Size() int {
	return m.Size()
}
func (m *Provider) XXX_DiscardUnknown() {
	xxx_messageInfo_Provider.DiscardUnknown(m)
}

var xxx_messageInfo_Provider proto.InternalMessageInfo

func (m *Provider) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *Provider) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type ProviderFilter struct {
	MerchantId string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
}

func (m *ProviderFilter) Reset()      { *m = ProviderFilter{} }
func (*ProviderFilter) ProtoMessage() {}
func (*ProviderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{17}
}
func (m *ProviderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderFilter.Merge(m, src)
}
func (m *ProviderFilter) XXX_Size() int {
	return m.Size()
}
func (m *ProviderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderFilter proto.InternalMessageInfo

func (m *ProviderFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type ProviderList struct {
}

func (m *ProviderList) Reset()      { *m = ProviderList{} }
func (*ProviderList) ProtoMessage() {}
func (*ProviderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{18}
}
func (m *ProviderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderList.Merge(m, src)
}
func (m *ProviderList) XXX_Size() int {
	return m.Size()
}
func (m *ProviderList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderList.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderList proto.InternalMessageInfo

type Customer struct {
	CustomerId string `protobuf:"bytes,1,opt,name=customerId,proto3" json:"customerId,omitempty"`
	MerchantId string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
}

func (m *Customer) Reset()      { *m = Customer{} }
func (*Customer) ProtoMessage() {}
func (*Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{19}
}
func (m *Customer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Customer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Customer.Merge(m, src)
}
func (m *Customer) XXX_Size() int {
	return m.Size()
}
func (m *Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Customer proto.InternalMessageInfo

func (m *Customer) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *Customer) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type CustomerFilter struct {
	MerchantId string `protobuf:"bytes,10,opt,name=merchantId,proto3" json:"merchantId,omitempty"`
}

func (m *CustomerFilter) Reset()      { *m = CustomerFilter{} }
func (*CustomerFilter) ProtoMessage() {}
func (*CustomerFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{20}
}
func (m *CustomerFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomerFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomerFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomerFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomerFilter.Merge(m, src)
}
func (m *CustomerFilter) XXX_Size() int {
	return m.Size()
}
func (m *CustomerFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomerFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CustomerFilter proto.InternalMessageInfo

func (m *CustomerFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type CustomerList struct {
}

func (m *CustomerList) Reset()      { *m = CustomerList{} }
func (*CustomerList) ProtoMessage() {}
func (*CustomerList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{21}
}
func (m *CustomerList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomerList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomerList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomerList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomerList.Merge(m, src)
}
func (m *CustomerList) XXX_Size() int {
	return m.Size()
}
func (m *CustomerList) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomerList.DiscardUnknown(m)
}

var xxx_messageInfo_CustomerList proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("admin.v1.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterType((*Merchant)(nil), "admin.v1.Merchant")
	proto.RegisterType((*MerchantList)(nil), "admin.v1.MerchantList")
	proto.RegisterType((*User)(nil), "admin.v1.User")
	proto.RegisterType((*UserList)(nil), "admin.v1.UserList")
	proto.RegisterType((*Store)(nil), "admin.v1.Store")
	proto.RegisterType((*StoreList)(nil), "admin.v1.StoreList")
	proto.RegisterType((*ProductSchema)(nil), "admin.v1.ProductSchema")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.ProductSchema.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.ProductSchema.LabelsEntry")
	proto.RegisterType((*Product)(nil), "admin.v1.Product")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.Product.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.Product.LabelsEntry")
	proto.RegisterType((*UploadMeta)(nil), "admin.v1.UploadMeta")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.UploadMeta.LabelsEntry")
	proto.RegisterType((*Warehouse)(nil), "admin.v1.Warehouse")
	proto.RegisterType((*WarehouseFilter)(nil), "admin.v1.WarehouseFilter")
	proto.RegisterType((*WarehouseList)(nil), "admin.v1.WarehouseList")
	proto.RegisterType((*Order)(nil), "admin.v1.Order")
	proto.RegisterType((*OrderItem)(nil), "admin.v1.OrderItem")
	proto.RegisterType((*OrderList)(nil), "admin.v1.OrderList")
	proto.RegisterType((*OrderFilter)(nil), "admin.v1.OrderFilter")
	proto.RegisterType((*Provider)(nil), "admin.v1.Provider")
	proto.RegisterType((*ProviderFilter)(nil), "admin.v1.ProviderFilter")
	proto.RegisterType((*ProviderList)(nil), "admin.v1.ProviderList")
	proto.RegisterType((*Customer)(nil), "admin.v1.Customer")
	proto.RegisterType((*CustomerFilter)(nil), "admin.v1.CustomerFilter")
	proto.RegisterType((*CustomerList)(nil), "admin.v1.CustomerList")
}

func init() { proto.RegisterFile("v1/admin_api.proto", fileDescriptor_667592b98ca79aba) }

var fileDescriptor_667592b98ca79aba = []byte{
	// 1664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0xd6, 0xf0, 0x47, 0x26, 0x8b, 0xbf, 0x6a, 0x79, 0x15, 0x66, 0xb2, 0xcb, 0xe5, 0x8e, 0x77,
	0xd7, 0xb2, 0x62, 0x73, 0x56, 0xdc, 0x04, 0xf1, 0x6a, 0xb1, 0x0b, 0xd0, 0x12, 0x2d, 0x30, 0xb0,
	0x25, 0x83, 0x94, 0x1c, 0xd8, 0x40, 0x20, 0x8c, 0x38, 0x2d, 0x69, 0x20, 0x92, 0xc3, 0xcc, 0x34,
	0x19, 0x28, 0x86, 0x81, 0x20, 0x4f, 0x60, 0xc0, 0xc7, 0xe4, 0xe0, 0xa3, 0x5f, 0x22, 0xe7, 0xe4,
	0xe8, 0x20, 0x08, 0xe0, 0x63, 0x2c, 0x07, 0x41, 0x8e, 0x7e, 0x84, 0xa0, 0x6b, 0xa6, 0xe7, 0x8f,
	0xa4, 0x46, 0x76, 0x72, 0xd8, 0xdb, 0x74, 0x75, 0xd5, 0x57, 0xf5, 0x55, 0x55, 0x77, 0x17, 0x09,
	0x64, 0xb2, 0xae, 0x6a, 0xfa, 0xc0, 0x18, 0x1e, 0x68, 0x23, 0xa3, 0x3e, 0xb2, 0x4c, 0x66, 0x92,
	0x0c, 0x0a, 0xea, 0x93, 0x75, 0xf9, 0xe3, 0x63, 0xd3, 0x3c, 0xee, 0x53, 0x55, 0x1b, 0x19, 0xaa,
	0x36, 0x1c, 0x9a, 0x4c, 0x63, 0x86, 0x39, 0xb4, 0x1d, 0x3d, 0xf9, 0x27, 0xee, 0x2e, 0xae, 0x0e,
	0xc7, 0x47, 0x2a, 0x1d, 0x8c, 0xd8, 0x99, 0xbb, 0x59, 0x9a, 0xac, 0xab, 0x3d, 0x73, 0x30, 0x30,
	0x87, 0x8e, 0x40, 0xf9, 0x1e, 0x32, 0xf7, 0xa9, 0xd5, 0x3b, 0xd1, 0x86, 0x8c, 0x54, 0x01, 0x06,
	0xee, 0x77, 0x5b, 0xaf, 0x48, 0x35, 0x69, 0x35, 0xdb, 0x09, 0x48, 0x08, 0x81, 0xd4, 0x50, 0x1b,
	0xd0, 0x4a, 0x02, 0x77, 0xf0, 0x5b, 0xb9, 0x0d, 0x79, 0x61, 0x7f, 0xcf, 0xb0, 0x19, 0x59, 0x85,
	0xb4, 0xc1, 0xe8, 0xc0, 0xae, 0x48, 0xb5, 0xe4, 0x6a, 0xae, 0x41, 0xea, 0x22, 0xea, 0xba, 0x50,
	0xeb, 0x38, 0x0a, 0xca, 0x0b, 0x09, 0x52, 0xfb, 0x36, 0xb5, 0x48, 0x11, 0x12, 0x86, 0x70, 0x97,
	0x30, 0x66, 0xba, 0x21, 0x57, 0x21, 0x4d, 0x07, 0x9a, 0xd1, 0xaf, 0xa4, 0x50, 0xe8, 0x2c, 0x48,
	0x0d, 0x72, 0xc6, 0x70, 0x62, 0x30, 0xaa, 0xdf, 0x39, 0x6b, 0xeb, 0x95, 0x34, 0xee, 0x05, 0x45,
	0x11, 0x4a, 0x30, 0x45, 0xe9, 0x63, 0xc8, 0xb2, 0x93, 0xf1, 0xe0, 0x70, 0xc8, 0xb1, 0x1b, 0xb8,
	0xed, 0x0b, 0x94, 0xaf, 0x20, 0xc3, 0x23, 0x44, 0x62, 0x9f, 0x87, 0x89, 0x15, 0x7d, 0x62, 0x5c,
	0x45, 0x90, 0xfa, 0x0d, 0xa4, 0xbb, 0xcc, 0xb4, 0x28, 0xa9, 0xc0, 0x15, 0x9b, 0x7f, 0x78, 0x89,
	0x14, 0xcb, 0x99, 0xf4, 0x64, 0xc8, 0xf4, 0xcd, 0x1e, 0x96, 0xb1, 0x92, 0x44, 0xb9, 0xb7, 0x8e,
	0xa3, 0xa0, 0x34, 0x20, 0x8b, 0x2e, 0x31, 0xca, 0x2f, 0xc2, 0x51, 0x96, 0xfc, 0x28, 0x51, 0x47,
	0x84, 0xf9, 0xc7, 0x24, 0x14, 0x1e, 0x58, 0xa6, 0x3e, 0xee, 0xb1, 0x6e, 0xef, 0x84, 0x0e, 0x34,
	0xb2, 0x0a, 0xa5, 0x51, 0x50, 0xe0, 0xc5, 0x1d, 0x15, 0xcf, 0x8c, 0xff, 0x26, 0x64, 0x7b, 0x16,
	0xd5, 0x30, 0xeb, 0x48, 0x60, 0x3a, 0x41, 0xbe, 0x42, 0x6c, 0x51, 0xbe, 0x85, 0xc5, 0xbe, 0x76,
	0x48, 0xfb, 0x76, 0xe5, 0x2a, 0xb2, 0xb8, 0xe6, 0x43, 0x85, 0x82, 0xae, 0xdf, 0x43, 0xad, 0xd6,
	0x90, 0x59, 0x67, 0x1d, 0xd7, 0x84, 0x6c, 0x03, 0x68, 0x8c, 0x59, 0xc6, 0xe1, 0x98, 0x51, 0xbb,
	0xa2, 0x23, 0xc0, 0xf5, 0x79, 0x00, 0x4d, 0x4f, 0xd3, 0x01, 0x09, 0x98, 0xca, 0xdf, 0x40, 0x2e,
	0x80, 0x4f, 0xca, 0x90, 0x3c, 0xa5, 0x67, 0x6e, 0x52, 0xf8, 0x27, 0xef, 0xc9, 0x89, 0xd6, 0x1f,
	0x8b, 0x4c, 0x38, 0x8b, 0x8d, 0xc4, 0x6d, 0x49, 0xfe, 0x0e, 0x4a, 0x11, 0xe4, 0xf7, 0x31, 0x57,
	0xfe, 0x9c, 0x82, 0x2b, 0x6e, 0x9c, 0xbc, 0x41, 0xdd, 0x02, 0x78, 0x15, 0xf1, 0x05, 0xe4, 0x3b,
	0x28, 0x84, 0xca, 0x83, 0x58, 0xb9, 0xc6, 0x8f, 0xe6, 0xf0, 0xed, 0x84, 0xb5, 0x63, 0x0b, 0x21,
	0x43, 0xc6, 0xed, 0x5a, 0xbb, 0x92, 0xab, 0x25, 0x79, 0x5b, 0x8a, 0x35, 0xb7, 0x1d, 0x59, 0xe6,
	0xc4, 0xd0, 0xa9, 0xd5, 0xd6, 0x2b, 0x79, 0xc7, 0xd6, 0x97, 0x78, 0x6d, 0x52, 0x08, 0xb4, 0x49,
	0x0d, 0x72, 0x3a, 0xb5, 0x7b, 0x96, 0x31, 0xc2, 0x4e, 0x2f, 0x3a, 0xe7, 0x35, 0x20, 0x22, 0xbf,
	0x80, 0x82, 0x4e, 0x8f, 0xb4, 0x71, 0x9f, 0x35, 0x07, 0xe6, 0x78, 0xc8, 0x2a, 0x25, 0x24, 0xb4,
	0x54, 0x77, 0x2f, 0xad, 0xc9, 0x7a, 0xdd, 0xd9, 0xe8, 0x84, 0xf5, 0xc8, 0x0a, 0x2c, 0x1a, 0x03,
	0xed, 0x98, 0xda, 0x95, 0x32, 0x06, 0xea, 0xae, 0xc8, 0xcf, 0x23, 0xbd, 0xf4, 0xc9, 0x54, 0x6a,
	0x66, 0x76, 0x51, 0x73, 0x46, 0x17, 0x7d, 0x36, 0x6d, 0xfa, 0xc3, 0xec, 0x9f, 0xbf, 0x49, 0x00,
	0xfb, 0xa3, 0xbe, 0xa9, 0xe9, 0xf7, 0x29, 0xd3, 0x78, 0x15, 0x8f, 0x8c, 0x3e, 0xdd, 0xe1, 0xd5,
	0x70, 0xec, 0xbd, 0x35, 0xaf, 0x52, 0xdf, 0x18, 0x9e, 0x8a, 0xc3, 0xcc, 0xbf, 0x63, 0xbb, 0xe2,
	0x76, 0x24, 0xa5, 0xb5, 0xc0, 0x49, 0xf7, 0xbc, 0xce, 0xca, 0xea, 0xff, 0x90, 0x12, 0x25, 0x07,
	0xd9, 0x5f, 0x69, 0x16, 0x3d, 0x31, 0xc7, 0x36, 0x55, 0x96, 0xa0, 0xe4, 0x2d, 0xee, 0x1a, 0x7d,
	0x46, 0x2d, 0x65, 0x03, 0x0a, 0x9e, 0x08, 0x6f, 0xc2, 0x1b, 0xe1, 0x9b, 0x70, 0xd9, 0x0f, 0xd2,
	0xd3, 0x13, 0xb7, 0xe1, 0x9f, 0x12, 0x90, 0xde, 0xb5, 0x74, 0x6a, 0xf1, 0x5b, 0xdb, 0xb4, 0x9c,
	0x8e, 0x76, 0x6f, 0x6d, 0x77, 0x49, 0x6e, 0xc1, 0xa2, 0xcd, 0x34, 0x36, 0xb6, 0x31, 0xb4, 0x62,
	0xe3, 0x23, 0x1f, 0x0f, 0x4d, 0xbb, 0xb8, 0xd9, 0x71, 0x95, 0xb0, 0xfb, 0x4d, 0x46, 0xdd, 0xcb,
	0x1c, 0xbf, 0xfd, 0x88, 0x52, 0xd1, 0x88, 0x10, 0xa1, 0xcd, 0xe8, 0xc0, 0x8d, 0x88, 0x7c, 0x0d,
	0x39, 0x66, 0x32, 0xad, 0xef, 0x1e, 0x82, 0xf4, 0xbc, 0x43, 0x10, 0xd4, 0xe2, 0x57, 0x85, 0x7b,
	0xc7, 0x36, 0x59, 0x65, 0xb1, 0x26, 0xad, 0x26, 0x3b, 0xbe, 0x20, 0xb6, 0xaa, 0x81, 0x07, 0x2b,
	0x17, 0x7a, 0xb0, 0x94, 0xe7, 0x12, 0x64, 0xbd, 0x08, 0xc9, 0x4f, 0xe1, 0x8a, 0x7b, 0x89, 0x60,
	0x8a, 0x78, 0x58, 0xd1, 0x63, 0xd1, 0x11, 0x1a, 0xbc, 0x9e, 0x3d, 0x64, 0xc0, 0x93, 0x96, 0xee,
	0x38, 0x0b, 0x72, 0x03, 0x16, 0x35, 0x87, 0x58, 0x72, 0x1e, 0x31, 0x57, 0x21, 0x58, 0x10, 0x08,
	0x15, 0x84, 0x3f, 0x7b, 0x18, 0x54, 0xcc, 0xb3, 0x87, 0x3a, 0xa2, 0xd0, 0xcf, 0x24, 0xc8, 0xa1,
	0xc0, 0x69, 0x9a, 0xff, 0x5f, 0xb9, 0x3f, 0x3c, 0xb9, 0xbf, 0x84, 0xcc, 0x03, 0xf7, 0xd2, 0x8c,
	0x5c, 0xa9, 0xd2, 0xd4, 0x95, 0x1a, 0x37, 0x09, 0x7c, 0x05, 0x45, 0x81, 0xe5, 0x12, 0x8c, 0xb3,
	0x28, 0x42, 0x5e, 0x58, 0xf0, 0x3c, 0xf2, 0x68, 0x36, 0xc7, 0x36, 0x33, 0x07, 0x8e, 0x6d, 0xcf,
	0xfd, 0xf6, 0xa3, 0xf1, 0x25, 0x97, 0x89, 0x46, 0x60, 0x5d, 0x3e, 0x1a, 0x61, 0xc1, 0xa3, 0x59,
	0x3b, 0x75, 0xab, 0xe5, 0x24, 0x9b, 0xc8, 0xb0, 0xb2, 0xdb, 0xd9, 0x6a, 0x75, 0x0e, 0xba, 0x7b,
	0xcd, 0xbd, 0xfd, 0xee, 0xc1, 0xfe, 0xce, 0x56, 0xeb, 0x6e, 0x7b, 0xa7, 0xb5, 0x55, 0x5e, 0x20,
	0x4b, 0x50, 0xd8, 0xd9, 0xdd, 0x3b, 0xe8, 0xee, 0xdf, 0xb9, 0xdf, 0xde, 0xdb, 0x6b, 0x6d, 0x95,
	0x25, 0x52, 0x80, 0xac, 0xbf, 0x4c, 0x90, 0x0c, 0xa4, 0x1e, 0x34, 0xdb, 0x5b, 0xe5, 0x24, 0xff,
	0xea, 0xb6, 0x76, 0xf6, 0xca, 0x29, 0x02, 0xb0, 0xb8, 0xd9, 0xdc, 0xd9, 0x6c, 0xdd, 0x2b, 0xa7,
	0x1b, 0x2f, 0x52, 0x50, 0x12, 0x23, 0x6a, 0x97, 0x5a, 0x13, 0xa3, 0x47, 0xc9, 0x43, 0x58, 0xda,
	0xc4, 0x03, 0x24, 0x36, 0xb6, 0xac, 0x33, 0x32, 0x63, 0xa4, 0x95, 0x67, 0xc8, 0x94, 0x1f, 0xff,
	0xe1, 0xef, 0xff, 0x7a, 0x9e, 0x58, 0x56, 0x8a, 0xaa, 0x6e, 0x9d, 0xa9, 0x82, 0xa6, 0xbd, 0x21,
	0xad, 0x91, 0x5d, 0x28, 0x86, 0x71, 0x2f, 0x0d, 0xfa, 0x11, 0x82, 0x96, 0x14, 0x08, 0x03, 0x76,
	0x20, 0xbf, 0x4d, 0x99, 0xd0, 0xb2, 0xc9, 0x4a, 0xdd, 0xf9, 0x11, 0x50, 0x17, 0x3f, 0x02, 0xea,
	0x2d, 0xfe, 0x23, 0x40, 0x5e, 0x99, 0x86, 0xc4, 0xba, 0x13, 0x84, 0xcd, 0x93, 0x00, 0x2c, 0xf9,
	0x35, 0x14, 0xda, 0x38, 0x49, 0xf3, 0xf1, 0x8d, 0x13, 0x8f, 0x4c, 0x74, 0x72, 0x64, 0xad, 0xdc,
	0x44, 0x90, 0x2f, 0x95, 0xcf, 0xc2, 0x84, 0xd5, 0x27, 0x7e, 0x89, 0x9f, 0xaa, 0x63, 0x9b, 0x5a,
	0x18, 0xf2, 0x43, 0x00, 0x1f, 0x3e, 0x16, 0x7b, 0x15, 0xb1, 0x15, 0xe5, 0x93, 0x58, 0xdc, 0x47,
	0x90, 0xd9, 0xa6, 0x8c, 0x1b, 0xd9, 0x71, 0x59, 0x15, 0xb3, 0xbd, 0xf2, 0x05, 0xa2, 0x7f, 0x4a,
	0x2e, 0x46, 0x6f, 0xbc, 0x4c, 0x40, 0x1e, 0xc7, 0x68, 0xd1, 0x1f, 0x9a, 0xa8, 0x23, 0x4a, 0x79,
	0x8e, 0xa2, 0x03, 0xb7, 0x1c, 0x15, 0x28, 0xb7, 0xd0, 0xd7, 0x75, 0x45, 0xb9, 0x28, 0x4b, 0x78,
	0x3b, 0x20, 0x9d, 0xc7, 0x90, 0x0b, 0xb8, 0xb8, 0x04, 0xfe, 0x0d, 0xc4, 0xbf, 0xa6, 0x54, 0xe3,
	0xb1, 0x1f, 0x41, 0x76, 0x9b, 0x32, 0x34, 0xb3, 0xa7, 0x91, 0x97, 0x23, 0x02, 0xcc, 0xd4, 0x97,
	0x88, 0x5e, 0x23, 0x31, 0xe8, 0x8d, 0x7f, 0x24, 0xa1, 0xdc, 0x1e, 0x4e, 0xe8, 0x90, 0x99, 0xd6,
	0x99, 0x48, 0xd7, 0xef, 0x60, 0xc5, 0xe1, 0x12, 0x1a, 0x4a, 0x79, 0xda, 0xe6, 0x0d, 0xac, 0xf2,
	0xbc, 0x0d, 0xa5, 0x8e, 0x81, 0xac, 0x2a, 0xd7, 0x2e, 0x4c, 0x23, 0xea, 0x22, 0x57, 0x1b, 0x96,
	0x67, 0xf8, 0xfe, 0x00, 0xc7, 0x6b, 0xe8, 0xf8, 0x73, 0xe5, 0xd3, 0x4b, 0x38, 0xa5, 0x90, 0x77,
	0x9c, 0x3a, 0x73, 0x11, 0xb9, 0x3a, 0x6b, 0x52, 0x92, 0x67, 0x4a, 0xe3, 0xeb, 0x38, 0x46, 0x5d,
	0xee, 0xc6, 0x80, 0x42, 0x88, 0x1b, 0x99, 0x7e, 0x92, 0xe5, 0x69, 0x91, 0xd2, 0x40, 0x0f, 0x37,
	0x95, 0xeb, 0xf3, 0x3c, 0xb8, 0xaf, 0xb8, 0xbd, 0xe1, 0x4c, 0x11, 0x1b, 0xd2, 0x5a, 0x83, 0x40,
	0xd9, 0x1b, 0x9f, 0xdc, 0xb2, 0x36, 0xfe, 0x92, 0x84, 0xbc, 0x73, 0x4f, 0xbb, 0x75, 0x3e, 0x15,
	0x3d, 0xeb, 0x0c, 0x55, 0xd1, 0xd7, 0x58, 0x8e, 0x0a, 0x94, 0x0d, 0x8c, 0xe4, 0x67, 0x8a, 0x7a,
	0x71, 0x57, 0xa9, 0x4f, 0xdc, 0x57, 0xf3, 0xa9, 0x8a, 0xef, 0x34, 0xe6, 0x78, 0x0c, 0xb9, 0xfd,
	0x91, 0xfe, 0x1e, 0xce, 0xb6, 0xd0, 0xd9, 0xf7, 0xf2, 0x37, 0xef, 0xe9, 0x4c, 0x7d, 0xe2, 0x0e,
	0x07, 0x4f, 0xb9, 0x5b, 0x0b, 0x72, 0x9b, 0xda, 0xb0, 0x47, 0xfb, 0x97, 0x75, 0xdb, 0x44, 0xb7,
	0xdf, 0xae, 0x7d, 0xb8, 0x5b, 0x72, 0x80, 0xe7, 0x15, 0xe1, 0x6c, 0x12, 0x9d, 0x48, 0x9c, 0x37,
	0x56, 0x8e, 0x4e, 0x95, 0x97, 0x3b, 0xb5, 0x8e, 0xab, 0xc6, 0xbf, 0x25, 0x28, 0x89, 0x79, 0x40,
	0x14, 0xf3, 0x48, 0xdc, 0x71, 0xde, 0x98, 0x42, 0x42, 0xad, 0x84, 0x32, 0x79, 0x86, 0x2c, 0xf0,
	0x1e, 0xcc, 0xef, 0x2f, 0xd4, 0xc4, 0x3a, 0x9e, 0xe2, 0x13, 0x26, 0x8c, 0x6d, 0x52, 0x99, 0x46,
	0x74, 0x29, 0xae, 0x4c, 0xef, 0x20, 0x4b, 0xf7, 0xc4, 0x90, 0x78, 0x7f, 0x48, 0x54, 0x8c, 0x1a,
	0x53, 0x44, 0xbd, 0x09, 0x28, 0x40, 0x4a, 0xc8, 0xe4, 0x19, 0xb2, 0x78, 0xa2, 0x62, 0x6a, 0x0a,
	0x10, 0x15, 0xc6, 0x21, 0xa2, 0xe1, 0x79, 0x29, 0x48, 0x34, 0x38, 0x17, 0xc5, 0x13, 0xf5, 0xfc,
	0xdd, 0xd1, 0x5f, 0xbd, 0xa9, 0x2e, 0xbc, 0x7e, 0x53, 0x5d, 0x78, 0xf7, 0xa6, 0x2a, 0xfd, 0xfe,
	0xbc, 0x2a, 0xbd, 0x3c, 0xaf, 0x4a, 0x7f, 0x3d, 0xaf, 0x4a, 0xaf, 0xce, 0xab, 0xd2, 0x3f, 0xcf,
	0xab, 0xd2, 0x7f, 0xce, 0xab, 0x0b, 0xef, 0xce, 0xab, 0xd2, 0xb3, 0xb7, 0xd5, 0x85, 0x57, 0x6f,
	0xab, 0x0b, 0xaf, 0xdf, 0x56, 0x17, 0x1e, 0xd7, 0x8f, 0x0d, 0x76, 0x32, 0x3e, 0xe4, 0x63, 0xb9,
	0x7a, 0xd4, 0x37, 0x7f, 0x3b, 0x1e, 0xa9, 0x27, 0x54, 0xd3, 0xfb, 0xd4, 0xb6, 0xb5, 0x91, 0x61,
	0xab, 0xc7, 0xe6, 0x2d, 0x5b, 0x3f, 0x75, 0xfe, 0xa1, 0x54, 0x27, 0xeb, 0x87, 0x8b, 0x38, 0x66,
	0x7c, 0xfd, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xc4, 0x09, 0x44, 0xb7, 0x14, 0x00, 0x00,
}

func (x OrderStatus) String() string {
	s, ok := OrderStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Merchant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Merchant)
	if !ok {
		that2, ok := that.(Merchant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MerchantList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MerchantList)
	if !ok {
		that2, ok := that.(MerchantList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.InvitedById != that1.InvitedById {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Thumbnail != that1.Thumbnail {
		return false
	}
	return true
}
func (this *UserList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserList)
	if !ok {
		that2, ok := that.(UserList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *Store) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Store)
	if !ok {
		that2, ok := that.(Store)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *StoreList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreList)
	if !ok {
		that2, ok := that.(StoreList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ProductSchema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductSchema)
	if !ok {
		that2, ok := that.(ProductSchema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductSchemaId != that1.ProductSchemaId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.CreatedBy.Equal(that1.CreatedBy) {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if !this.ProductSchema.Equal(that1.ProductSchema) {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.StoreIds) != len(that1.StoreIds) {
		return false
	}
	for i := range this.StoreIds {
		if this.StoreIds[i] != that1.StoreIds[i] {
			return false
		}
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.DefaultAmount.Equal(that1.DefaultAmount) {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if this.Images[i] != that1.Images[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *UploadMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadMeta)
	if !ok {
		that2, ok := that.(UploadMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if this.Link != that1.Link {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *Warehouse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Warehouse)
	if !ok {
		that2, ok := that.(Warehouse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *WarehouseFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WarehouseFilter)
	if !ok {
		that2, ok := that.(WarehouseFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *WarehouseList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WarehouseList)
	if !ok {
		that2, ok := that.(WarehouseList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Note != that1.Note {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if !this.TotalAmount.Equal(that1.TotalAmount) {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *OrderItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderItem)
	if !ok {
		that2, ok := that.(OrderItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *OrderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderList)
	if !ok {
		that2, ok := that.(OrderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *OrderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderFilter)
	if !ok {
		that2, ok := that.(OrderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *Provider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Provider)
	if !ok {
		that2, ok := that.(Provider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *ProviderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderFilter)
	if !ok {
		that2, ok := that.(ProviderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *ProviderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderList)
	if !ok {
		that2, ok := that.(ProviderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Customer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Customer)
	if !ok {
		that2, ok := that.(Customer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CustomerFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomerFilter)
	if !ok {
		that2, ok := that.(CustomerFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CustomerList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomerList)
	if !ok {
		that2, ok := that.(CustomerList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Merchant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Merchant{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MerchantList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.MerchantList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1.User{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "InvitedById: "+fmt.Sprintf("%#v", this.InvitedById)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.UserList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Store) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.Store{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.StoreList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductSchema) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1.ProductSchema{")
	s = append(s, "ProductSchemaId: "+fmt.Sprintf("%#v", this.ProductSchemaId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.CreatedBy != nil {
		s = append(s, "CreatedBy: "+fmt.Sprintf("%#v", this.CreatedBy)+",\n")
	}
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&v1.Product{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	if this.ProductSchema != nil {
		s = append(s, "ProductSchema: "+fmt.Sprintf("%#v", this.ProductSchema)+",\n")
	}
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreIds: "+fmt.Sprintf("%#v", this.StoreIds)+",\n")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.DefaultAmount != nil {
		s = append(s, "DefaultAmount: "+fmt.Sprintf("%#v", this.DefaultAmount)+",\n")
	}
	s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.UploadMeta{")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Warehouse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.Warehouse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WarehouseFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.WarehouseFilter{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WarehouseList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.WarehouseList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&v1.Order{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Note: "+fmt.Sprintf("%#v", this.Note)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	if this.TotalAmount != nil {
		s = append(s, "TotalAmount: "+fmt.Sprintf("%#v", this.TotalAmount)+",\n")
	}
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.OrderItem{")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.OrderFilter{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Provider) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Provider{")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.ProviderFilter{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.ProviderList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Customer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Customer{")
	s = append(s, "CustomerId: "+fmt.Sprintf("%#v", this.CustomerId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CustomerFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.CustomerFilter{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CustomerList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.CustomerList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAdminApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MerchantServiceClient is the client API for MerchantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MerchantServiceClient interface {
	// CreateMerchantDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the merchant
	CreateMerchantDry(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error)
	// CreateMerchant creates a merchant in the database and returns the object
	// back with populated data
	CreateMerchant(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error)
	// GetMerchants returns a list of merchants the user has access to
	GetMerchants(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MerchantList, error)
	// InviteUserDry validates the provided user for existence. correct email,
	// and other required fields by user invitation process
	InviteUserDry(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// InviteUser creates a user account for the user in case it didn't exist before.
	// Otherwise it invites the user into the merchant
	InviteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// GetUsers returns all users present in the merchant
	GetUsers(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*UserList, error)
}

type merchantServiceClient struct {
	cc *grpc.ClientConn
}

func NewMerchantServiceClient(cc *grpc.ClientConn) MerchantServiceClient {
	return &merchantServiceClient{cc}
}

func (c *merchantServiceClient) CreateMerchantDry(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error) {
	out := new(Merchant)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/CreateMerchantDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) CreateMerchant(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error) {
	out := new(Merchant)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/CreateMerchant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) GetMerchants(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MerchantList, error) {
	out := new(MerchantList)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/GetMerchants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) InviteUserDry(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/InviteUserDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) InviteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/InviteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) GetUsers(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MerchantServiceServer is the server API for MerchantService service.
type MerchantServiceServer interface {
	// CreateMerchantDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the merchant
	CreateMerchantDry(context.Context, *Merchant) (*Merchant, error)
	// CreateMerchant creates a merchant in the database and returns the object
	// back with populated data
	CreateMerchant(context.Context, *Merchant) (*Merchant, error)
	// GetMerchants returns a list of merchants the user has access to
	GetMerchants(context.Context, *empty.Empty) (*MerchantList, error)
	// InviteUserDry validates the provided user for existence. correct email,
	// and other required fields by user invitation process
	InviteUserDry(context.Context, *User) (*User, error)
	// InviteUser creates a user account for the user in case it didn't exist before.
	// Otherwise it invites the user into the merchant
	InviteUser(context.Context, *User) (*User, error)
	// GetUsers returns all users present in the merchant
	GetUsers(context.Context, *Merchant) (*UserList, error)
}

func RegisterMerchantServiceServer(s *grpc.Server, srv MerchantServiceServer) {
	s.RegisterService(&_MerchantService_serviceDesc, srv)
}

func _MerchantService_CreateMerchantDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).CreateMerchantDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/CreateMerchantDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).CreateMerchantDry(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_CreateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/CreateMerchant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_GetMerchants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).GetMerchants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/GetMerchants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).GetMerchants(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_InviteUserDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).InviteUserDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/InviteUserDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).InviteUserDry(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_InviteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).InviteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/InviteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).InviteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).GetUsers(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

var _MerchantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.MerchantService",
	HandlerType: (*MerchantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMerchantDry",
			Handler:    _MerchantService_CreateMerchantDry_Handler,
		},
		{
			MethodName: "CreateMerchant",
			Handler:    _MerchantService_CreateMerchant_Handler,
		},
		{
			MethodName: "GetMerchants",
			Handler:    _MerchantService_GetMerchants_Handler,
		},
		{
			MethodName: "InviteUserDry",
			Handler:    _MerchantService_InviteUserDry_Handler,
		},
		{
			MethodName: "InviteUser",
			Handler:    _MerchantService_InviteUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _MerchantService_GetUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// StoreServiceClient is the client API for StoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreServiceClient interface {
	// CreateStoreDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the store
	// for the particular merchant
	CreateStoreDry(ctx context.Context, in *Store, opts ...grpc.CallOption) (*Store, error)
	// Create store creates the store for the particular merchant and returns
	// the store object back to the caller
	CreateStore(ctx context.Context, in *Store, opts ...grpc.CallOption) (*Store, error)
	// Loads all stores from given merchant
	GetStores(ctx context.Context, in *Store, opts ...grpc.CallOption) (*StoreList, error)
}

type storeServiceClient struct {
	cc *grpc.ClientConn
}

func NewStoreServiceClient(cc *grpc.ClientConn) StoreServiceClient {
	return &storeServiceClient{cc}
}

func (c *storeServiceClient) CreateStoreDry(ctx context.Context, in *Store, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/CreateStoreDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) CreateStore(ctx context.Context, in *Store, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/CreateStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) GetStores(ctx context.Context, in *Store, opts ...grpc.CallOption) (*StoreList, error) {
	out := new(StoreList)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/GetStores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoreServiceServer is the server API for StoreService service.
type StoreServiceServer interface {
	// CreateStoreDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the store
	// for the particular merchant
	CreateStoreDry(context.Context, *Store) (*Store, error)
	// Create store creates the store for the particular merchant and returns
	// the store object back to the caller
	CreateStore(context.Context, *Store) (*Store, error)
	// Loads all stores from given merchant
	GetStores(context.Context, *Store) (*StoreList, error)
}

func RegisterStoreServiceServer(s *grpc.Server, srv StoreServiceServer) {
	s.RegisterService(&_StoreService_serviceDesc, srv)
}

func _StoreService_CreateStoreDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Store)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).CreateStoreDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/CreateStoreDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).CreateStoreDry(ctx, req.(*Store))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_CreateStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Store)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).CreateStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/CreateStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).CreateStore(ctx, req.(*Store))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_GetStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Store)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).GetStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/GetStores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).GetStores(ctx, req.(*Store))
	}
	return interceptor(ctx, in, info, handler)
}

var _StoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.StoreService",
	HandlerType: (*StoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStoreDry",
			Handler:    _StoreService_CreateStoreDry_Handler,
		},
		{
			MethodName: "CreateStore",
			Handler:    _StoreService_CreateStore_Handler,
		},
		{
			MethodName: "GetStores",
			Handler:    _StoreService_GetStores_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// InventoryServiceClient is the client API for InventoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InventoryServiceClient interface {
	// CreateProductSchemaDry validates provided product schema and returns a list
	// of errors or the product schema on success
	CreateProductSchemaDry(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error)
	// CreateProductSchema creates the product schema in the system
	CreateProductSchema(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error)
	// CreateUpload creates an upload link for the merchant gallery
	CreateUpload(ctx context.Context, in *UploadMeta, opts ...grpc.CallOption) (*UploadMeta, error)
	// CreateProduct creates a product in the firestore for a particular merchant
	CreateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
}

type inventoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewInventoryServiceClient(cc *grpc.ClientConn) InventoryServiceClient {
	return &inventoryServiceClient{cc}
}

func (c *inventoryServiceClient) CreateProductSchemaDry(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error) {
	out := new(ProductSchema)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/CreateProductSchemaDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) CreateProductSchema(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error) {
	out := new(ProductSchema)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/CreateProductSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) CreateUpload(ctx context.Context, in *UploadMeta, opts ...grpc.CallOption) (*UploadMeta, error) {
	out := new(UploadMeta)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/CreateUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) CreateProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/CreateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServiceServer is the server API for InventoryService service.
type InventoryServiceServer interface {
	// CreateProductSchemaDry validates provided product schema and returns a list
	// of errors or the product schema on success
	CreateProductSchemaDry(context.Context, *ProductSchema) (*ProductSchema, error)
	// CreateProductSchema creates the product schema in the system
	CreateProductSchema(context.Context, *ProductSchema) (*ProductSchema, error)
	// CreateUpload creates an upload link for the merchant gallery
	CreateUpload(context.Context, *UploadMeta) (*UploadMeta, error)
	// CreateProduct creates a product in the firestore for a particular merchant
	CreateProduct(context.Context, *Product) (*Product, error)
}

func RegisterInventoryServiceServer(s *grpc.Server, srv InventoryServiceServer) {
	s.RegisterService(&_InventoryService_serviceDesc, srv)
}

func _InventoryService_CreateProductSchemaDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).CreateProductSchemaDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/CreateProductSchemaDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).CreateProductSchemaDry(ctx, req.(*ProductSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_CreateProductSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).CreateProductSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/CreateProductSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).CreateProductSchema(ctx, req.(*ProductSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_CreateUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).CreateUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/CreateUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).CreateUpload(ctx, req.(*UploadMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/CreateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).CreateProduct(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

var _InventoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.InventoryService",
	HandlerType: (*InventoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProductSchemaDry",
			Handler:    _InventoryService_CreateProductSchemaDry_Handler,
		},
		{
			MethodName: "CreateProductSchema",
			Handler:    _InventoryService_CreateProductSchema_Handler,
		},
		{
			MethodName: "CreateUpload",
			Handler:    _InventoryService_CreateUpload_Handler,
		},
		{
			MethodName: "CreateProduct",
			Handler:    _InventoryService_CreateProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// WarehouseServiceClient is the client API for WarehouseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WarehouseServiceClient interface {
}

type warehouseServiceClient struct {
	cc *grpc.ClientConn
}

func NewWarehouseServiceClient(cc *grpc.ClientConn) WarehouseServiceClient {
	return &warehouseServiceClient{cc}
}

// WarehouseServiceServer is the server API for WarehouseService service.
type WarehouseServiceServer interface {
}

func RegisterWarehouseServiceServer(s *grpc.Server, srv WarehouseServiceServer) {
	s.RegisterService(&_WarehouseService_serviceDesc, srv)
}

var _WarehouseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.WarehouseService",
	HandlerType: (*WarehouseServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "v1/admin_api.proto",
}

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderServiceClient interface {
	// CreateOrder creates an order for the particular user in the store
	CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	CancelOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/CreateOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/UpdateOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) CancelOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error) {
	out := new(OrderList)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/GetOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
type OrderServiceServer interface {
	// CreateOrder creates an order for the particular user in the store
	CreateOrder(context.Context, *Order) (*Order, error)
	UpdateOrder(context.Context, *Order) (*Order, error)
	CancelOrder(context.Context, *Order) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(context.Context, *OrderFilter) (*OrderList, error)
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/CreateOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_UpdateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).UpdateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/UpdateOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).UpdateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CancelOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/GetOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrders(ctx, req.(*OrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrder",
			Handler:    _OrderService_CreateOrder_Handler,
		},
		{
			MethodName: "UpdateOrder",
			Handler:    _OrderService_UpdateOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _OrderService_CancelOrder_Handler,
		},
		{
			MethodName: "GetOrders",
			Handler:    _OrderService_GetOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// ProviderServiceClient is the client API for ProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProviderServiceClient interface {
	// CreateProvider creates a provider for the particular merchant
	CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Provider, error)
	// GetProviders returns all providers that the user has access to
	GetProviders(ctx context.Context, in *ProviderFilter, opts ...grpc.CallOption) (*ProviderList, error)
}

type providerServiceClient struct {
	cc *grpc.ClientConn
}

func NewProviderServiceClient(cc *grpc.ClientConn) ProviderServiceClient {
	return &providerServiceClient{cc}
}

func (c *providerServiceClient) CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Provider, error) {
	out := new(Provider)
	err := c.cc.Invoke(ctx, "/admin.v1.ProviderService/CreateProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) GetProviders(ctx context.Context, in *ProviderFilter, opts ...grpc.CallOption) (*ProviderList, error) {
	out := new(ProviderList)
	err := c.cc.Invoke(ctx, "/admin.v1.ProviderService/GetProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProviderServiceServer is the server API for ProviderService service.
type ProviderServiceServer interface {
	// CreateProvider creates a provider for the particular merchant
	CreateProvider(context.Context, *Provider) (*Provider, error)
	// GetProviders returns all providers that the user has access to
	GetProviders(context.Context, *ProviderFilter) (*ProviderList, error)
}

func RegisterProviderServiceServer(s *grpc.Server, srv ProviderServiceServer) {
	s.RegisterService(&_ProviderService_serviceDesc, srv)
}

func _ProviderService_CreateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Provider)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).CreateProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProviderService/CreateProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).CreateProvider(ctx, req.(*Provider))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_GetProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProviderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).GetProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProviderService/GetProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).GetProviders(ctx, req.(*ProviderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProviderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.ProviderService",
	HandlerType: (*ProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProvider",
			Handler:    _ProviderService_CreateProvider_Handler,
		},
		{
			MethodName: "GetProviders",
			Handler:    _ProviderService_GetProviders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// CustomerServiceClient is the client API for CustomerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomerServiceClient interface {
	// CreateCustomer creates a customer for the particular merchant
	CreateCustomer(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error)
	// GetCustomers returns all customers that the user has access to
	GetCustomers(ctx context.Context, in *CustomerFilter, opts ...grpc.CallOption) (*CustomerList, error)
}

type customerServiceClient struct {
	cc *grpc.ClientConn
}

func NewCustomerServiceClient(cc *grpc.ClientConn) CustomerServiceClient {
	return &customerServiceClient{cc}
}

func (c *customerServiceClient) CreateCustomer(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/admin.v1.CustomerService/CreateCustomer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerServiceClient) GetCustomers(ctx context.Context, in *CustomerFilter, opts ...grpc.CallOption) (*CustomerList, error) {
	out := new(CustomerList)
	err := c.cc.Invoke(ctx, "/admin.v1.CustomerService/GetCustomers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerServiceServer is the server API for CustomerService service.
type CustomerServiceServer interface {
	// CreateCustomer creates a customer for the particular merchant
	CreateCustomer(context.Context, *Customer) (*Customer, error)
	// GetCustomers returns all customers that the user has access to
	GetCustomers(context.Context, *CustomerFilter) (*CustomerList, error)
}

func RegisterCustomerServiceServer(s *grpc.Server, srv CustomerServiceServer) {
	s.RegisterService(&_CustomerService_serviceDesc, srv)
}

func _CustomerService_CreateCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Customer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).CreateCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.CustomerService/CreateCustomer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).CreateCustomer(ctx, req.(*Customer))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerService_GetCustomers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).GetCustomers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.CustomerService/GetCustomers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).GetCustomers(ctx, req.(*CustomerFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.CustomerService",
	HandlerType: (*CustomerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCustomer",
			Handler:    _CustomerService_CreateCustomer_Handler,
		},
		{
			MethodName: "GetCustomers",
			Handler:    _CustomerService_GetCustomers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

func (m *Merchant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merchant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *MerchantList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerchantList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.InvitedById) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InvitedById)))
		i += copy(dAtA[i:], m.InvitedById)
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.Thumbnail) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Thumbnail)))
		i += copy(dAtA[i:], m.Thumbnail)
	}
	return i, nil
}

func (m *UserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Store) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Store) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i += copy(dAtA[i:], m.StoreId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	return i, nil
}

func (m *StoreList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductSchemaId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductSchemaId)))
		i += copy(dAtA[i:], m.ProductSchemaId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.CreatedBy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.CreatedBy.Size()))
		n1, err := m.CreatedBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			i = encodeVarintAdminApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			v := m.Attributes[k]
			mapSize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			i = encodeVarintAdminApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i += copy(dAtA[i:], m.ProductId)
	}
	if m.ProductSchema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.ProductSchema.Size()))
		n2, err := m.ProductSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.StoreIds) > 0 {
		for _, s := range m.StoreIds {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProviderId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i += copy(dAtA[i:], m.ProviderId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DefaultAmount != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.DefaultAmount.Size()))
		n3, err := m.DefaultAmount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			i = encodeVarintAdminApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			v := m.Attributes[k]
			mapSize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			i = encodeVarintAdminApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *UploadMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			i = encodeVarintAdminApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Warehouse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Warehouse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WarehouseFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarehouseFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WarehouseList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarehouseList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Status))
	}
	if len(m.Note) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Note)))
		i += copy(dAtA[i:], m.Note)
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalAmount != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.TotalAmount.Size()))
		n4, err := m.TotalAmount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.CreatedAt))
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.StoreId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i += copy(dAtA[i:], m.StoreId)
	}
	return i, nil
}

func (m *OrderItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Product != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Product.Size()))
		n5, err := m.Product.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Count))
	}
	if m.Amount != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Amount.Size()))
		n6, err := m.Amount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.OrderId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	return i, nil
}

func (m *OrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdminApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OrderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Status))
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	if len(m.StoreId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i += copy(dAtA[i:], m.StoreId)
	}
	return i, nil
}

func (m *Provider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Provider) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProviderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i += copy(dAtA[i:], m.ProviderId)
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	return i, nil
}

func (m *ProviderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	return i, nil
}

func (m *ProviderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Customer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CustomerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.CustomerId)))
		i += copy(dAtA[i:], m.CustomerId)
	}
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	return i, nil
}

func (m *CustomerFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i += copy(dAtA[i:], m.MerchantId)
	}
	return i, nil
}

func (m *CustomerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintAdminApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Merchant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *MerchantList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InvitedById)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 2 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *UserList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *Store) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *StoreList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ProductSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductSchemaId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedBy != nil {
		l = m.CreatedBy.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.ProductSchema != nil {
		l = m.ProductSchema.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.StoreIds) > 0 {
		for _, s := range m.StoreIds {
			l = len(s)
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.DefaultAmount != nil {
		l = m.DefaultAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UploadMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Warehouse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WarehouseFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WarehouseList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAdminApi(uint64(m.Status))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	if m.TotalAmount != nil {
		l = m.TotalAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovAdminApi(uint64(m.CreatedAt))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *OrderItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovAdminApi(uint64(m.Count))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *OrderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *OrderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAdminApi(uint64(m.Status))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *Provider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *ProviderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *ProviderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Customer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CustomerFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CustomerList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovAdminApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdminApi(x uint64) (n int) {
	return sovAdminApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Merchant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Merchant{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MerchantList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MerchantList{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "Merchant", "Merchant", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *User) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&User{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`InvitedById:` + fmt.Sprintf("%v", this.InvitedById) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Thumbnail:` + fmt.Sprintf("%v", this.Thumbnail) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserList{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "User", "User", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Store) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Store{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreList{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "Store", "Store", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductSchema) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&ProductSchema{`,
		`ProductSchemaId:` + fmt.Sprintf("%v", this.ProductSchemaId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`CreatedBy:` + strings.Replace(fmt.Sprintf("%v", this.CreatedBy), "User", "User", 1) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&Product{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`ProductSchema:` + strings.Replace(fmt.Sprintf("%v", this.ProductSchema), "ProductSchema", "ProductSchema", 1) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreIds:` + fmt.Sprintf("%v", this.StoreIds) + `,`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultAmount:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAmount), "Amount", "v1.Amount", 1) + `,`,
		`Images:` + fmt.Sprintf("%v", this.Images) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadMeta) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&UploadMeta{`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`Link:` + fmt.Sprintf("%v", this.Link) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *Warehouse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Warehouse{`,
		`}`,
	}, "")
	return s
}
func (this *WarehouseFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WarehouseFilter{`,
		`}`,
	}, "")
	return s
}
func (this *WarehouseList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WarehouseList{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "Warehouse", "Warehouse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Note:` + fmt.Sprintf("%v", this.Note) + `,`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "OrderItem", "OrderItem", 1) + `,`,
		`TotalAmount:` + strings.Replace(fmt.Sprintf("%v", this.TotalAmount), "Amount", "v1.Amount", 1) + `,`,
		`CreatedAt:` + fmt.Sprintf("%v", this.CreatedAt) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderItem{`,
		`Product:` + strings.Replace(fmt.Sprintf("%v", this.Product), "Product", "Product", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderList{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "Order", "Order", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderFilter{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Provider) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Provider{`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProviderFilter{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProviderList{`,
		`}`,
	}, "")
	return s
}
func (this *Customer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Customer{`,
		`CustomerId:` + fmt.Sprintf("%v", this.CustomerId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomerFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomerFilter{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomerList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomerList{`,
		`}`,
	}, "")
	return s
}
func valueToStringAdminApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Merchant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merchant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merchant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerchantList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerchantList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerchantList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Merchant{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvitedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &User{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Store{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSchemaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSchemaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedBy == nil {
				m.CreatedBy = &User{}
			}
			if err := m.CreatedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProductSchema == nil {
				m.ProductSchema = &ProductSchema{}
			}
			if err := m.ProductSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreIds = append(m.StoreIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultAmount == nil {
				m.DefaultAmount = &v1.Amount{}
			}
			if err := m.DefaultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Warehouse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Warehouse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Warehouse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarehouseFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarehouseFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarehouseFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarehouseList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarehouseList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarehouseList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Warehouse{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &OrderItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalAmount == nil {
				m.TotalAmount = &v1.Amount{}
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Order{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Provider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdminApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdminApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAdminApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdminApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAdminApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdminApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdminApi   = fmt.Errorf("proto: integer overflow")
)
