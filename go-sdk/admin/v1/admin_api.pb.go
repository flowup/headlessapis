// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/admin_api.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/flowup/headlessapis/go-sdk/common/v1"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderStatus int32

const (
	ORDER_STATUS_UNDEFINED OrderStatus = 0
	NOT_SUBMITTED          OrderStatus = 1
	SUBMITTED              OrderStatus = 2
	PAID                   OrderStatus = 3
	SENT                   OrderStatus = 4
	CANCEL                 OrderStatus = 5
)

var OrderStatus_name = map[int32]string{
	0: "ORDER_STATUS_UNDEFINED",
	1: "NOT_SUBMITTED",
	2: "SUBMITTED",
	3: "PAID",
	4: "SENT",
	5: "CANCEL",
}

var OrderStatus_value = map[string]int32{
	"ORDER_STATUS_UNDEFINED": 0,
	"NOT_SUBMITTED":          1,
	"SUBMITTED":              2,
	"PAID":                   3,
	"SENT":                   4,
	"CANCEL":                 5,
}

func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{0}
}

type Merchant struct {
	// [Required] merchant_id can be set only once and is unchangeable during lifetime
	MerchantId string `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	// [Required] name of the merchant can be customized by the user, however, the id
	// will stay unchanged
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Merchant) Reset()      { *m = Merchant{} }
func (*Merchant) ProtoMessage() {}
func (*Merchant) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{0}
}
func (m *Merchant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merchant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merchant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merchant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merchant.Merge(m, src)
}
func (m *Merchant) XXX_Size() int {
	return m.Size()
}
func (m *Merchant) XXX_DiscardUnknown() {
	xxx_messageInfo_Merchant.DiscardUnknown(m)
}

var xxx_messageInfo_Merchant proto.InternalMessageInfo

func (m *Merchant) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Merchant) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MerchantList struct {
	Items []*Merchant `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *MerchantList) Reset()      { *m = MerchantList{} }
func (*MerchantList) ProtoMessage() {}
func (*MerchantList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{1}
}
func (m *MerchantList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerchantList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerchantList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerchantList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerchantList.Merge(m, src)
}
func (m *MerchantList) XXX_Size() int {
	return m.Size()
}
func (m *MerchantList) XXX_DiscardUnknown() {
	xxx_messageInfo_MerchantList.DiscardUnknown(m)
}

var xxx_messageInfo_MerchantList proto.InternalMessageInfo

func (m *MerchantList) GetItems() []*Merchant {
	if m != nil {
		return m.Items
	}
	return nil
}

type User struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Email string `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	// id of the user this user was invited by into the system
	InvitedById string `protobuf:"bytes,5,opt,name=invited_by_id,json=invitedById,proto3" json:"invited_by_id,omitempty"`
	MerchantId  string `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Thumbnail   string `protobuf:"bytes,50,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *User) Reset()      { *m = User{} }
func (*User) ProtoMessage() {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{2}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetInvitedById() string {
	if m != nil {
		return m.InvitedById
	}
	return ""
}

func (m *User) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *User) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

type UserList struct {
	Items []*User `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *UserList) Reset()      { *m = UserList{} }
func (*UserList) ProtoMessage() {}
func (*UserList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{3}
}
func (m *UserList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserList.Merge(m, src)
}
func (m *UserList) XXX_Size() int {
	return m.Size()
}
func (m *UserList) XXX_DiscardUnknown() {
	xxx_messageInfo_UserList.DiscardUnknown(m)
}

var xxx_messageInfo_UserList proto.InternalMessageInfo

func (m *UserList) GetItems() []*User {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request for loading all stores for given merchant.
type ListStoresRequest struct {
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *ListStoresRequest) Reset()      { *m = ListStoresRequest{} }
func (*ListStoresRequest) ProtoMessage() {}
func (*ListStoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{4}
}
func (m *ListStoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListStoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListStoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListStoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListStoresRequest.Merge(m, src)
}
func (m *ListStoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListStoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListStoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListStoresRequest proto.InternalMessageInfo

func (m *ListStoresRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

// Request for loading single store by ID from given merchant.
type GetStoreRequest struct {
	StoreId    string `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *GetStoreRequest) Reset()      { *m = GetStoreRequest{} }
func (*GetStoreRequest) ProtoMessage() {}
func (*GetStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{5}
}
func (m *GetStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreRequest.Merge(m, src)
}
func (m *GetStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreRequest proto.InternalMessageInfo

func (m *GetStoreRequest) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *GetStoreRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

// Request for create store in Firestore database
type CreateStoreRequest struct {
	// Optional custom ID
	StoreId    string `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Name       string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	//    string location = 11;
	Address     string `protobuf:"bytes,12,opt,name=address,proto3" json:"address,omitempty"`
	Description string `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *CreateStoreRequest) Reset()      { *m = CreateStoreRequest{} }
func (*CreateStoreRequest) ProtoMessage() {}
func (*CreateStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{6}
}
func (m *CreateStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStoreRequest.Merge(m, src)
}
func (m *CreateStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStoreRequest proto.InternalMessageInfo

func (m *CreateStoreRequest) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *CreateStoreRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *CreateStoreRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateStoreRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CreateStoreRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Request for update store in Firestore database
type UpdateStoreRequest struct {
	StoreId    string `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Name       string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	//    string location = 11;
	Address      string   `protobuf:"bytes,12,opt,name=address,proto3" json:"address,omitempty"`
	Description  string   `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
	InventoryIds []string `protobuf:"bytes,50,rep,name=inventory_ids,json=inventoryIds,proto3" json:"inventory_ids,omitempty"`
}

func (m *UpdateStoreRequest) Reset()      { *m = UpdateStoreRequest{} }
func (*UpdateStoreRequest) ProtoMessage() {}
func (*UpdateStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{7}
}
func (m *UpdateStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateStoreRequest.Merge(m, src)
}
func (m *UpdateStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateStoreRequest proto.InternalMessageInfo

func (m *UpdateStoreRequest) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *UpdateStoreRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *UpdateStoreRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateStoreRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *UpdateStoreRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UpdateStoreRequest) GetInventoryIds() []string {
	if m != nil {
		return m.InventoryIds
	}
	return nil
}

type Store struct {
	StoreId    string           `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string           `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	CreatedAt  *types.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Name       string           `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	//    string location = 11;
	Address      string   `protobuf:"bytes,12,opt,name=address,proto3" json:"address,omitempty"`
	Description  string   `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
	InventoryIds []string `protobuf:"bytes,50,rep,name=inventory_ids,json=inventoryIds,proto3" json:"inventory_ids,omitempty"`
}

func (m *Store) Reset()      { *m = Store{} }
func (*Store) ProtoMessage() {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{8}
}
func (m *Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return m.Size()
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *Store) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Store) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Store) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Store) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Store) GetInventoryIds() []string {
	if m != nil {
		return m.InventoryIds
	}
	return nil
}

type StoreDetails struct {
	StoreId    string           `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string           `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	CreatedAt  *types.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Name       string           `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	//    string location = 11;
	Address        string           `protobuf:"bytes,12,opt,name=address,proto3" json:"address,omitempty"`
	Description    string           `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
	ProductCounter uint32           `protobuf:"varint,30,opt,name=product_counter,json=productCounter,proto3" json:"product_counter,omitempty"`
	ItemCounter    uint32           `protobuf:"varint,31,opt,name=item_counter,json=itemCounter,proto3" json:"item_counter,omitempty"`
	InventoryIds   []string         `protobuf:"bytes,50,rep,name=inventory_ids,json=inventoryIds,proto3" json:"inventory_ids,omitempty"`
	Items          []*InventoryItem `protobuf:"bytes,51,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *StoreDetails) Reset()      { *m = StoreDetails{} }
func (*StoreDetails) ProtoMessage() {}
func (*StoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{9}
}
func (m *StoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreDetails.Merge(m, src)
}
func (m *StoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *StoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_StoreDetails proto.InternalMessageInfo

func (m *StoreDetails) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *StoreDetails) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *StoreDetails) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *StoreDetails) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StoreDetails) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *StoreDetails) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StoreDetails) GetProductCounter() uint32 {
	if m != nil {
		return m.ProductCounter
	}
	return 0
}

func (m *StoreDetails) GetItemCounter() uint32 {
	if m != nil {
		return m.ItemCounter
	}
	return 0
}

func (m *StoreDetails) GetInventoryIds() []string {
	if m != nil {
		return m.InventoryIds
	}
	return nil
}

func (m *StoreDetails) GetItems() []*InventoryItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type StoreList struct {
	Items []*Store `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *StoreList) Reset()      { *m = StoreList{} }
func (*StoreList) ProtoMessage() {}
func (*StoreList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{10}
}
func (m *StoreList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreList.Merge(m, src)
}
func (m *StoreList) XXX_Size() int {
	return m.Size()
}
func (m *StoreList) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreList.DiscardUnknown(m)
}

var xxx_messageInfo_StoreList proto.InternalMessageInfo

func (m *StoreList) GetItems() []*Store {
	if m != nil {
		return m.Items
	}
	return nil
}

type ListInventoryItemsRequest struct {
	MerchantId  string `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	InventoryId string `protobuf:"bytes,2,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id,omitempty"`
}

func (m *ListInventoryItemsRequest) Reset()      { *m = ListInventoryItemsRequest{} }
func (*ListInventoryItemsRequest) ProtoMessage() {}
func (*ListInventoryItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{11}
}
func (m *ListInventoryItemsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListInventoryItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListInventoryItemsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListInventoryItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInventoryItemsRequest.Merge(m, src)
}
func (m *ListInventoryItemsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListInventoryItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInventoryItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListInventoryItemsRequest proto.InternalMessageInfo

func (m *ListInventoryItemsRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *ListInventoryItemsRequest) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

// Request for adding product items within inventory.
type AddInventoryItemRequest struct {
	MerchantId  string     `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	InventoryId string     `protobuf:"bytes,2,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id,omitempty"`
	ProductId   string     `protobuf:"bytes,3,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Amount      *v1.Amount `protobuf:"bytes,50,opt,name=amount,proto3" json:"amount,omitempty"`
	Count       uint32     `protobuf:"varint,51,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *AddInventoryItemRequest) Reset()      { *m = AddInventoryItemRequest{} }
func (*AddInventoryItemRequest) ProtoMessage() {}
func (*AddInventoryItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{12}
}
func (m *AddInventoryItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddInventoryItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddInventoryItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddInventoryItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddInventoryItemRequest.Merge(m, src)
}
func (m *AddInventoryItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddInventoryItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddInventoryItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddInventoryItemRequest proto.InternalMessageInfo

func (m *AddInventoryItemRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *AddInventoryItemRequest) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

func (m *AddInventoryItemRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *AddInventoryItemRequest) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *AddInventoryItemRequest) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Request for updating product items within inventory.
type UpdateInventoryItemRequest struct {
	MerchantId  string     `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	InventoryId string     `protobuf:"bytes,2,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id,omitempty"`
	ProductId   string     `protobuf:"bytes,3,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Amount      *v1.Amount `protobuf:"bytes,50,opt,name=amount,proto3" json:"amount,omitempty"`
	Count       uint32     `protobuf:"varint,51,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *UpdateInventoryItemRequest) Reset()      { *m = UpdateInventoryItemRequest{} }
func (*UpdateInventoryItemRequest) ProtoMessage() {}
func (*UpdateInventoryItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{13}
}
func (m *UpdateInventoryItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateInventoryItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateInventoryItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateInventoryItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateInventoryItemRequest.Merge(m, src)
}
func (m *UpdateInventoryItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateInventoryItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateInventoryItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateInventoryItemRequest proto.InternalMessageInfo

func (m *UpdateInventoryItemRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *UpdateInventoryItemRequest) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

func (m *UpdateInventoryItemRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *UpdateInventoryItemRequest) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *UpdateInventoryItemRequest) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Response message for InventoryItem model.
type InventoryItem struct {
	MerchantId  string           `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	ProductId   string           `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	InventoryId string           `protobuf:"bytes,3,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id,omitempty"`
	CreatedAt   *types.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Amount      *v1.Amount       `protobuf:"bytes,10,opt,name=amount,proto3" json:"amount,omitempty"`
	Count       uint32           `protobuf:"varint,11,opt,name=count,proto3" json:"count,omitempty"`
	Product     *Product         `protobuf:"bytes,50,opt,name=product,proto3" json:"product,omitempty"`
}

func (m *InventoryItem) Reset()      { *m = InventoryItem{} }
func (*InventoryItem) ProtoMessage() {}
func (*InventoryItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{14}
}
func (m *InventoryItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryItem.Merge(m, src)
}
func (m *InventoryItem) XXX_Size() int {
	return m.Size()
}
func (m *InventoryItem) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryItem.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryItem proto.InternalMessageInfo

func (m *InventoryItem) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *InventoryItem) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *InventoryItem) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

func (m *InventoryItem) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *InventoryItem) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *InventoryItem) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *InventoryItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

type InventoryItemList struct {
	Items []*InventoryItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *InventoryItemList) Reset()      { *m = InventoryItemList{} }
func (*InventoryItemList) ProtoMessage() {}
func (*InventoryItemList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{15}
}
func (m *InventoryItemList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryItemList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryItemList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryItemList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryItemList.Merge(m, src)
}
func (m *InventoryItemList) XXX_Size() int {
	return m.Size()
}
func (m *InventoryItemList) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryItemList.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryItemList proto.InternalMessageInfo

func (m *InventoryItemList) GetItems() []*InventoryItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ListProductsRequest struct {
	// Required. Id of the merchant to which the product is assigned
	MerchantId string `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	// Expressions used for filtering
	Filter []*v1.Expression `protobuf:"bytes,2,rep,name=filter,proto3" json:"filter,omitempty"`
}

func (m *ListProductsRequest) Reset()      { *m = ListProductsRequest{} }
func (*ListProductsRequest) ProtoMessage() {}
func (*ListProductsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{16}
}
func (m *ListProductsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListProductsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListProductsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListProductsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListProductsRequest.Merge(m, src)
}
func (m *ListProductsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListProductsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListProductsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListProductsRequest proto.InternalMessageInfo

func (m *ListProductsRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *ListProductsRequest) GetFilter() []*v1.Expression {
	if m != nil {
		return m.Filter
	}
	return nil
}

type ProductList struct {
	Items []*Product `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ProductList) Reset()      { *m = ProductList{} }
func (*ProductList) ProtoMessage() {}
func (*ProductList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{17}
}
func (m *ProductList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductList.Merge(m, src)
}
func (m *ProductList) XXX_Size() int {
	return m.Size()
}
func (m *ProductList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductList.DiscardUnknown(m)
}

var xxx_messageInfo_ProductList proto.InternalMessageInfo

func (m *ProductList) GetItems() []*Product {
	if m != nil {
		return m.Items
	}
	return nil
}

type ProductSchema struct {
	ProductSchemaId string `protobuf:"bytes,1,opt,name=product_schema_id,json=productSchemaId,proto3" json:"product_schema_id,omitempty"`
	Name            string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// createdBy is a reference to the user that created this product schema
	CreatedBy  *User             `protobuf:"bytes,3,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	MerchantId string            `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Labels     map[string]string `protobuf:"bytes,100,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,101,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProductSchema) Reset()      { *m = ProductSchema{} }
func (*ProductSchema) ProtoMessage() {}
func (*ProductSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{18}
}
func (m *ProductSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductSchema.Merge(m, src)
}
func (m *ProductSchema) XXX_Size() int {
	return m.Size()
}
func (m *ProductSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductSchema.DiscardUnknown(m)
}

var xxx_messageInfo_ProductSchema proto.InternalMessageInfo

func (m *ProductSchema) GetProductSchemaId() string {
	if m != nil {
		return m.ProductSchemaId
	}
	return ""
}

func (m *ProductSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductSchema) GetCreatedBy() *User {
	if m != nil {
		return m.CreatedBy
	}
	return nil
}

func (m *ProductSchema) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *ProductSchema) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ProductSchema) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type GetProductRequest struct {
	// Required. Id of the product
	ProductId string `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	// Required. Id of the merchant to which the product is assigned
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *GetProductRequest) Reset()      { *m = GetProductRequest{} }
func (*GetProductRequest) ProtoMessage() {}
func (*GetProductRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{19}
}
func (m *GetProductRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProductRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProductRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProductRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProductRequest.Merge(m, src)
}
func (m *GetProductRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetProductRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProductRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetProductRequest proto.InternalMessageInfo

func (m *GetProductRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *GetProductRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type CreateProductRequest struct {
	ProductId string `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	// Required. Id of the merchant to which the product is assigned
	MerchantId    string            `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreIds      []string          `protobuf:"bytes,11,rep,name=store_ids,json=storeIds,proto3" json:"store_ids,omitempty"`
	ProviderId    string            `protobuf:"bytes,12,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	Name          string            `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	Description   string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	DefaultAmount *v1.Amount        `protobuf:"bytes,15,opt,name=default_amount,json=defaultAmount,proto3" json:"default_amount,omitempty"`
	Images        []string          `protobuf:"bytes,16,rep,name=images,proto3" json:"images,omitempty"`
	Labels        map[string]string `protobuf:"bytes,100,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,101,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateProductRequest) Reset()      { *m = CreateProductRequest{} }
func (*CreateProductRequest) ProtoMessage() {}
func (*CreateProductRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{20}
}
func (m *CreateProductRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProductRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProductRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProductRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProductRequest.Merge(m, src)
}
func (m *CreateProductRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateProductRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProductRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProductRequest proto.InternalMessageInfo

func (m *CreateProductRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *CreateProductRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *CreateProductRequest) GetStoreIds() []string {
	if m != nil {
		return m.StoreIds
	}
	return nil
}

func (m *CreateProductRequest) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *CreateProductRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateProductRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateProductRequest) GetDefaultAmount() *v1.Amount {
	if m != nil {
		return m.DefaultAmount
	}
	return nil
}

func (m *CreateProductRequest) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *CreateProductRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *CreateProductRequest) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type UpdateProductRequest struct {
	ProductId string `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	// Required. Id of the merchant to which the product is assigned
	MerchantId    string            `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreIds      []string          `protobuf:"bytes,11,rep,name=store_ids,json=storeIds,proto3" json:"store_ids,omitempty"`
	ProviderId    string            `protobuf:"bytes,12,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	Name          string            `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	Description   string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	DefaultAmount *v1.Amount        `protobuf:"bytes,15,opt,name=default_amount,json=defaultAmount,proto3" json:"default_amount,omitempty"`
	Images        []string          `protobuf:"bytes,16,rep,name=images,proto3" json:"images,omitempty"`
	Labels        map[string]string `protobuf:"bytes,100,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,101,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UpdateProductRequest) Reset()      { *m = UpdateProductRequest{} }
func (*UpdateProductRequest) ProtoMessage() {}
func (*UpdateProductRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{21}
}
func (m *UpdateProductRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateProductRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateProductRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateProductRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateProductRequest.Merge(m, src)
}
func (m *UpdateProductRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateProductRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateProductRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateProductRequest proto.InternalMessageInfo

func (m *UpdateProductRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *UpdateProductRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *UpdateProductRequest) GetStoreIds() []string {
	if m != nil {
		return m.StoreIds
	}
	return nil
}

func (m *UpdateProductRequest) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *UpdateProductRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateProductRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UpdateProductRequest) GetDefaultAmount() *v1.Amount {
	if m != nil {
		return m.DefaultAmount
	}
	return nil
}

func (m *UpdateProductRequest) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *UpdateProductRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *UpdateProductRequest) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Product struct {
	ProductId       string            `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	ProductSchemaId string            `protobuf:"bytes,2,opt,name=product_schema_id,json=productSchemaId,proto3" json:"product_schema_id,omitempty"`
	MerchantId      string            `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreIds        []string          `protobuf:"bytes,11,rep,name=store_ids,json=storeIds,proto3" json:"store_ids,omitempty"`
	ProviderId      string            `protobuf:"bytes,12,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	Name            string            `protobuf:"bytes,13,opt,name=name,proto3" json:"name,omitempty"`
	Description     string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	DefaultAmount   *v1.Amount        `protobuf:"bytes,15,opt,name=default_amount,json=defaultAmount,proto3" json:"default_amount,omitempty"`
	Images          []string          `protobuf:"bytes,16,rep,name=images,proto3" json:"images,omitempty"`
	Labels          map[string]string `protobuf:"bytes,100,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,101,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{22}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Product) GetProductSchemaId() string {
	if m != nil {
		return m.ProductSchemaId
	}
	return ""
}

func (m *Product) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Product) GetStoreIds() []string {
	if m != nil {
		return m.StoreIds
	}
	return nil
}

func (m *Product) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetDefaultAmount() *v1.Amount {
	if m != nil {
		return m.DefaultAmount
	}
	return nil
}

func (m *Product) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *Product) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Product) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type UploadMeta struct {
	// [Required] fileName is searchable throughout the system
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// [Output Only] this is being provided by the system after the file is uploaded
	Link       string            `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	MerchantId string            `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Labels     map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UploadMeta) Reset()      { *m = UploadMeta{} }
func (*UploadMeta) ProtoMessage() {}
func (*UploadMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{23}
}
func (m *UploadMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadMeta.Merge(m, src)
}
func (m *UploadMeta) XXX_Size() int {
	return m.Size()
}
func (m *UploadMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadMeta.DiscardUnknown(m)
}

var xxx_messageInfo_UploadMeta proto.InternalMessageInfo

func (m *UploadMeta) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadMeta) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *UploadMeta) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *UploadMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Warehouse struct {
}

func (m *Warehouse) Reset()      { *m = Warehouse{} }
func (*Warehouse) ProtoMessage() {}
func (*Warehouse) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{24}
}
func (m *Warehouse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Warehouse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Warehouse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Warehouse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Warehouse.Merge(m, src)
}
func (m *Warehouse) XXX_Size() int {
	return m.Size()
}
func (m *Warehouse) XXX_DiscardUnknown() {
	xxx_messageInfo_Warehouse.DiscardUnknown(m)
}

var xxx_messageInfo_Warehouse proto.InternalMessageInfo

type WarehouseFilter struct {
}

func (m *WarehouseFilter) Reset()      { *m = WarehouseFilter{} }
func (*WarehouseFilter) ProtoMessage() {}
func (*WarehouseFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{25}
}
func (m *WarehouseFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WarehouseFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WarehouseFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WarehouseFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WarehouseFilter.Merge(m, src)
}
func (m *WarehouseFilter) XXX_Size() int {
	return m.Size()
}
func (m *WarehouseFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WarehouseFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WarehouseFilter proto.InternalMessageInfo

type WarehouseList struct {
	Items []*Warehouse `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *WarehouseList) Reset()      { *m = WarehouseList{} }
func (*WarehouseList) ProtoMessage() {}
func (*WarehouseList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{26}
}
func (m *WarehouseList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WarehouseList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WarehouseList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WarehouseList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WarehouseList.Merge(m, src)
}
func (m *WarehouseList) XXX_Size() int {
	return m.Size()
}
func (m *WarehouseList) XXX_DiscardUnknown() {
	xxx_messageInfo_WarehouseList.DiscardUnknown(m)
}

var xxx_messageInfo_WarehouseList proto.InternalMessageInfo

func (m *WarehouseList) GetItems() []*Warehouse {
	if m != nil {
		return m.Items
	}
	return nil
}

type Order struct {
	OrderId     string       `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Status      OrderStatus  `protobuf:"varint,2,opt,name=status,proto3,enum=admin.v1.OrderStatus" json:"status,omitempty"`
	Note        string       `protobuf:"bytes,3,opt,name=note,proto3" json:"note,omitempty"`
	Items       []*OrderItem `protobuf:"bytes,4,rep,name=items,proto3" json:"items,omitempty"`
	TotalAmount *v1.Amount   `protobuf:"bytes,5,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	CreatedAt   int64        `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	MerchantId  string       `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreId     string       `protobuf:"bytes,11,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{27}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return ORDER_STATUS_UNDEFINED
}

func (m *Order) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *Order) GetItems() []*OrderItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Order) GetTotalAmount() *v1.Amount {
	if m != nil {
		return m.TotalAmount
	}
	return nil
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Order) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type OrderItem struct {
	Product *Product   `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	Count   int32      `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Amount  *v1.Amount `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	OrderId string     `protobuf:"bytes,10,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *OrderItem) Reset()      { *m = OrderItem{} }
func (*OrderItem) ProtoMessage() {}
func (*OrderItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{28}
}
func (m *OrderItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderItem.Merge(m, src)
}
func (m *OrderItem) XXX_Size() int {
	return m.Size()
}
func (m *OrderItem) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderItem.DiscardUnknown(m)
}

var xxx_messageInfo_OrderItem proto.InternalMessageInfo

func (m *OrderItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OrderItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *OrderItem) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *OrderItem) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type OrderList struct {
	Items []*Order `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *OrderList) Reset()      { *m = OrderList{} }
func (*OrderList) ProtoMessage() {}
func (*OrderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{29}
}
func (m *OrderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderList.Merge(m, src)
}
func (m *OrderList) XXX_Size() int {
	return m.Size()
}
func (m *OrderList) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderList.DiscardUnknown(m)
}

var xxx_messageInfo_OrderList proto.InternalMessageInfo

func (m *OrderList) GetItems() []*Order {
	if m != nil {
		return m.Items
	}
	return nil
}

type OrderFilter struct {
	OrderId    string        `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Status     []OrderStatus `protobuf:"varint,2,rep,packed,name=status,proto3,enum=admin.v1.OrderStatus" json:"status,omitempty"`
	MerchantId string        `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreId    string        `protobuf:"bytes,11,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
}

func (m *OrderFilter) Reset()      { *m = OrderFilter{} }
func (*OrderFilter) ProtoMessage() {}
func (*OrderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{30}
}
func (m *OrderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilter.Merge(m, src)
}
func (m *OrderFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilter proto.InternalMessageInfo

func (m *OrderFilter) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderFilter) GetStatus() []OrderStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *OrderFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *OrderFilter) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type Provider struct {
	ProviderId string `protobuf:"bytes,1,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
	MerchantId string `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *Provider) Reset()      { *m = Provider{} }
func (*Provider) ProtoMessage() {}
func (*Provider) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{31}
}
func (m *Provider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Provider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Provider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Provider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Provider.Merge(m, src)
}
func (m *Provider) XXX_Size() int {
	return m.Size()
}
func (m *Provider) XXX_DiscardUnknown() {
	xxx_messageInfo_Provider.DiscardUnknown(m)
}

var xxx_messageInfo_Provider proto.InternalMessageInfo

func (m *Provider) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *Provider) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type ProviderFilter struct {
	MerchantId string `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *ProviderFilter) Reset()      { *m = ProviderFilter{} }
func (*ProviderFilter) ProtoMessage() {}
func (*ProviderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{32}
}
func (m *ProviderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderFilter.Merge(m, src)
}
func (m *ProviderFilter) XXX_Size() int {
	return m.Size()
}
func (m *ProviderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderFilter proto.InternalMessageInfo

func (m *ProviderFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type ProviderList struct {
}

func (m *ProviderList) Reset()      { *m = ProviderList{} }
func (*ProviderList) ProtoMessage() {}
func (*ProviderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{33}
}
func (m *ProviderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderList.Merge(m, src)
}
func (m *ProviderList) XXX_Size() int {
	return m.Size()
}
func (m *ProviderList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderList.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderList proto.InternalMessageInfo

type Customer struct {
	CustomerId string `protobuf:"bytes,1,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	MerchantId string `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *Customer) Reset()      { *m = Customer{} }
func (*Customer) ProtoMessage() {}
func (*Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{34}
}
func (m *Customer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Customer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Customer.Merge(m, src)
}
func (m *Customer) XXX_Size() int {
	return m.Size()
}
func (m *Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Customer proto.InternalMessageInfo

func (m *Customer) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *Customer) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type CustomerFilter struct {
	MerchantId string `protobuf:"bytes,10,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *CustomerFilter) Reset()      { *m = CustomerFilter{} }
func (*CustomerFilter) ProtoMessage() {}
func (*CustomerFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{35}
}
func (m *CustomerFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomerFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomerFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomerFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomerFilter.Merge(m, src)
}
func (m *CustomerFilter) XXX_Size() int {
	return m.Size()
}
func (m *CustomerFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomerFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CustomerFilter proto.InternalMessageInfo

func (m *CustomerFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type CustomerList struct {
}

func (m *CustomerList) Reset()      { *m = CustomerList{} }
func (*CustomerList) ProtoMessage() {}
func (*CustomerList) Descriptor() ([]byte, []int) {
	return fileDescriptor_667592b98ca79aba, []int{36}
}
func (m *CustomerList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomerList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomerList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomerList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomerList.Merge(m, src)
}
func (m *CustomerList) XXX_Size() int {
	return m.Size()
}
func (m *CustomerList) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomerList.DiscardUnknown(m)
}

var xxx_messageInfo_CustomerList proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("admin.v1.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterType((*Merchant)(nil), "admin.v1.Merchant")
	proto.RegisterType((*MerchantList)(nil), "admin.v1.MerchantList")
	proto.RegisterType((*User)(nil), "admin.v1.User")
	proto.RegisterType((*UserList)(nil), "admin.v1.UserList")
	proto.RegisterType((*ListStoresRequest)(nil), "admin.v1.ListStoresRequest")
	proto.RegisterType((*GetStoreRequest)(nil), "admin.v1.GetStoreRequest")
	proto.RegisterType((*CreateStoreRequest)(nil), "admin.v1.CreateStoreRequest")
	proto.RegisterType((*UpdateStoreRequest)(nil), "admin.v1.UpdateStoreRequest")
	proto.RegisterType((*Store)(nil), "admin.v1.Store")
	proto.RegisterType((*StoreDetails)(nil), "admin.v1.StoreDetails")
	proto.RegisterType((*StoreList)(nil), "admin.v1.StoreList")
	proto.RegisterType((*ListInventoryItemsRequest)(nil), "admin.v1.ListInventoryItemsRequest")
	proto.RegisterType((*AddInventoryItemRequest)(nil), "admin.v1.AddInventoryItemRequest")
	proto.RegisterType((*UpdateInventoryItemRequest)(nil), "admin.v1.UpdateInventoryItemRequest")
	proto.RegisterType((*InventoryItem)(nil), "admin.v1.InventoryItem")
	proto.RegisterType((*InventoryItemList)(nil), "admin.v1.InventoryItemList")
	proto.RegisterType((*ListProductsRequest)(nil), "admin.v1.ListProductsRequest")
	proto.RegisterType((*ProductList)(nil), "admin.v1.ProductList")
	proto.RegisterType((*ProductSchema)(nil), "admin.v1.ProductSchema")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.ProductSchema.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.ProductSchema.LabelsEntry")
	proto.RegisterType((*GetProductRequest)(nil), "admin.v1.GetProductRequest")
	proto.RegisterType((*CreateProductRequest)(nil), "admin.v1.CreateProductRequest")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.CreateProductRequest.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.CreateProductRequest.LabelsEntry")
	proto.RegisterType((*UpdateProductRequest)(nil), "admin.v1.UpdateProductRequest")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.UpdateProductRequest.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.UpdateProductRequest.LabelsEntry")
	proto.RegisterType((*Product)(nil), "admin.v1.Product")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.Product.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.Product.LabelsEntry")
	proto.RegisterType((*UploadMeta)(nil), "admin.v1.UploadMeta")
	proto.RegisterMapType((map[string]string)(nil), "admin.v1.UploadMeta.LabelsEntry")
	proto.RegisterType((*Warehouse)(nil), "admin.v1.Warehouse")
	proto.RegisterType((*WarehouseFilter)(nil), "admin.v1.WarehouseFilter")
	proto.RegisterType((*WarehouseList)(nil), "admin.v1.WarehouseList")
	proto.RegisterType((*Order)(nil), "admin.v1.Order")
	proto.RegisterType((*OrderItem)(nil), "admin.v1.OrderItem")
	proto.RegisterType((*OrderList)(nil), "admin.v1.OrderList")
	proto.RegisterType((*OrderFilter)(nil), "admin.v1.OrderFilter")
	proto.RegisterType((*Provider)(nil), "admin.v1.Provider")
	proto.RegisterType((*ProviderFilter)(nil), "admin.v1.ProviderFilter")
	proto.RegisterType((*ProviderList)(nil), "admin.v1.ProviderList")
	proto.RegisterType((*Customer)(nil), "admin.v1.Customer")
	proto.RegisterType((*CustomerFilter)(nil), "admin.v1.CustomerFilter")
	proto.RegisterType((*CustomerList)(nil), "admin.v1.CustomerList")
}

func init() { proto.RegisterFile("v1/admin_api.proto", fileDescriptor_667592b98ca79aba) }

var fileDescriptor_667592b98ca79aba = []byte{
	// 2357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x1a, 0x4d, 0x6f, 0x1b, 0xc7,
	0x55, 0x4b, 0x52, 0xb2, 0xf8, 0x48, 0x4a, 0xd4, 0xc8, 0x56, 0xe8, 0xb5, 0x4d, 0xcb, 0x6b, 0x27,
	0x96, 0x99, 0x88, 0x8c, 0xe8, 0xd4, 0xb0, 0x9d, 0xb4, 0x85, 0xbe, 0x2c, 0xa8, 0xb5, 0x65, 0x97,
	0x92, 0x1a, 0x20, 0x87, 0xb2, 0x2b, 0xee, 0x48, 0x5a, 0x98, 0xe4, 0x32, 0xbb, 0x4b, 0x35, 0x84,
	0x61, 0xa0, 0xe8, 0x2f, 0x28, 0x90, 0x5c, 0x8a, 0x1e, 0x8a, 0x22, 0x40, 0x5b, 0xf4, 0x92, 0x5b,
	0x6f, 0x05, 0x7a, 0x2c, 0xd0, 0x8b, 0x81, 0x5c, 0x72, 0xac, 0xe5, 0x1e, 0x72, 0x6b, 0xae, 0x45,
	0x2f, 0xc5, 0xbc, 0x9d, 0xd9, 0x6f, 0x66, 0x29, 0x2b, 0x40, 0xdd, 0x8f, 0x1b, 0xe7, 0xcd, 0x9b,
	0xf7, 0x3d, 0x6f, 0xde, 0x7b, 0x4b, 0x20, 0x47, 0x4b, 0x35, 0x55, 0xeb, 0xe8, 0xdd, 0xa6, 0xda,
	0xd3, 0xab, 0x3d, 0xd3, 0xb0, 0x0d, 0x32, 0x89, 0x80, 0xea, 0xd1, 0x92, 0x7c, 0xf1, 0xc0, 0x30,
	0x0e, 0xda, 0xb4, 0xa6, 0xf6, 0xf4, 0x9a, 0xda, 0xed, 0x1a, 0xb6, 0x6a, 0xeb, 0x46, 0xd7, 0x72,
	0xf0, 0xe4, 0x0b, 0x7c, 0x17, 0x57, 0x7b, 0xfd, 0xfd, 0x1a, 0xed, 0xf4, 0xec, 0x01, 0xdf, 0xbc,
	0x1c, 0xde, 0xb4, 0xf5, 0x0e, 0xb5, 0x6c, 0xb5, 0xd3, 0xe3, 0x08, 0xd3, 0x47, 0x4b, 0xb5, 0x96,
	0xd1, 0xe9, 0x18, 0x5d, 0x07, 0xa0, 0x7c, 0x17, 0x26, 0x1f, 0x50, 0xb3, 0x75, 0xa8, 0x76, 0x6d,
	0x72, 0x19, 0x72, 0x1d, 0xfe, 0xbb, 0xa9, 0x6b, 0x25, 0x69, 0x5e, 0x5a, 0xc8, 0x36, 0x40, 0x80,
	0x36, 0x35, 0x42, 0x20, 0xd3, 0x55, 0x3b, 0xb4, 0x94, 0xc2, 0x1d, 0xfc, 0xad, 0xdc, 0x86, 0xbc,
	0x20, 0x70, 0x5f, 0xb7, 0x6c, 0xb2, 0x00, 0xe3, 0xba, 0x4d, 0x3b, 0x56, 0x49, 0x9a, 0x4f, 0x2f,
	0xe4, 0xea, 0xa4, 0x2a, 0xf4, 0xaa, 0x0a, 0xb4, 0x86, 0x83, 0xa0, 0x7c, 0x2a, 0x41, 0x66, 0xd7,
	0xa2, 0x26, 0x99, 0x82, 0x94, 0xcb, 0x2e, 0xa5, 0xc7, 0xb2, 0x21, 0x67, 0x61, 0x9c, 0x76, 0x54,
	0xbd, 0x5d, 0xca, 0x20, 0xd0, 0x59, 0x10, 0x05, 0x0a, 0x7a, 0xf7, 0x48, 0xb7, 0xa9, 0xd6, 0xdc,
	0x1b, 0x30, 0x99, 0xc7, 0x71, 0x37, 0xc7, 0x81, 0x2b, 0x83, 0x4d, 0x2d, 0xac, 0x15, 0x44, 0xb4,
	0xba, 0x08, 0x59, 0xfb, 0xb0, 0xdf, 0xd9, 0xeb, 0x32, 0xf2, 0x75, 0xdc, 0xf6, 0x00, 0xca, 0xdb,
	0x30, 0xc9, 0x84, 0x44, 0xdd, 0xae, 0x05, 0x75, 0x9b, 0xf2, 0x74, 0x63, 0x28, 0x42, 0xaf, 0x77,
	0x60, 0x86, 0x61, 0x6f, 0xdb, 0x86, 0x49, 0xad, 0x06, 0xfd, 0xb0, 0x4f, 0xad, 0x88, 0x6d, 0x53,
	0x61, 0x29, 0x94, 0x07, 0x30, 0xbd, 0x41, 0x9d, 0x43, 0xe2, 0xcc, 0x79, 0x98, 0xb4, 0xd8, 0xda,
	0x73, 0xc6, 0x19, 0x5c, 0x47, 0x95, 0x8a, 0x92, 0xfb, 0x8d, 0x04, 0x64, 0xd5, 0xa4, 0xaa, 0x4d,
	0xbf, 0x29, 0x92, 0xae, 0x5b, 0xc0, 0xe7, 0x96, 0x12, 0x9c, 0x51, 0x35, 0xcd, 0xa4, 0x96, 0x55,
	0xca, 0x3b, 0xe4, 0xf8, 0x92, 0xcc, 0x43, 0x4e, 0xa3, 0x56, 0xcb, 0xd4, 0x7b, 0x2c, 0x7a, 0x4b,
	0x05, 0xc7, 0x31, 0x3e, 0xd0, 0xf7, 0x32, 0x93, 0xb9, 0x62, 0x5e, 0xf9, 0x8b, 0x04, 0x64, 0xb7,
	0xa7, 0xbd, 0xc2, 0x82, 0x92, 0xab, 0x18, 0x65, 0xb4, 0x6b, 0x1b, 0x26, 0x0b, 0x32, 0xab, 0x54,
	0x9f, 0x4f, 0x2f, 0x64, 0x1b, 0x79, 0x17, 0xb8, 0xa9, 0x59, 0x5c, 0x9b, 0x7f, 0x48, 0x30, 0x8e,
	0x7a, 0x9c, 0x4a, 0x81, 0x3b, 0x00, 0x2d, 0xf4, 0x9d, 0xd6, 0x54, 0xed, 0x52, 0x7a, 0x5e, 0x5a,
	0xc8, 0xd5, 0xe5, 0xaa, 0x73, 0xb7, 0xab, 0xe2, 0x6e, 0x57, 0x77, 0xc4, 0xdd, 0x6e, 0x64, 0x39,
	0xf6, 0xb2, 0xfd, 0xef, 0xd4, 0xfd, 0x9f, 0x29, 0xc8, 0xa3, 0xee, 0x6b, 0xd4, 0x56, 0xf5, 0xb6,
	0xf5, 0xdf, 0x62, 0x82, 0xeb, 0x30, 0xdd, 0x33, 0x0d, 0xad, 0xdf, 0xb2, 0x9b, 0x2d, 0xa3, 0xdf,
	0xb5, 0xa9, 0x59, 0x2a, 0xcf, 0x4b, 0x0b, 0x85, 0xc6, 0x14, 0x07, 0xaf, 0x3a, 0x50, 0x72, 0x05,
	0xf2, 0x2c, 0x03, 0xb8, 0x58, 0x97, 0x11, 0x2b, 0xc7, 0x60, 0x02, 0x65, 0x14, 0x73, 0x92, 0x45,
	0x91, 0x66, 0x6e, 0x62, 0x9a, 0x79, 0xcd, 0x4b, 0x33, 0x9b, 0x2e, 0x9a, 0x4d, 0x3b, 0x3c, 0xdf,
	0x70, 0xeb, 0xd7, 0x21, 0x8b, 0xc6, 0xc7, 0x44, 0xf5, 0x7a, 0x30, 0x51, 0x4d, 0x7b, 0x14, 0x9c,
	0x4b, 0xc6, 0x33, 0x55, 0x13, 0xce, 0x33, 0xf4, 0x00, 0xd5, 0x61, 0x19, 0x2b, 0xfa, 0x1a, 0x30,
	0x75, 0x7d, 0xba, 0x70, 0x27, 0xe6, 0x7c, 0xaa, 0x28, 0x7f, 0x94, 0xe0, 0xb5, 0x65, 0x4d, 0x0b,
	0x8a, 0xfd, 0xcd, 0xd1, 0x27, 0x97, 0x00, 0x84, 0x6b, 0x74, 0x0d, 0xa3, 0x24, 0xdb, 0xc8, 0x72,
	0xc8, 0xa6, 0x46, 0x6e, 0xc0, 0x84, 0xda, 0x61, 0x96, 0xc7, 0xb4, 0x9e, 0xab, 0xcf, 0x54, 0xf9,
	0xdb, 0x77, 0xb4, 0x54, 0x5d, 0xc6, 0x8d, 0x06, 0x47, 0x60, 0xef, 0x0b, 0xba, 0xad, 0x74, 0x13,
	0x9d, 0xe6, 0x2c, 0x94, 0x3f, 0x49, 0x20, 0x3b, 0xc9, 0xe9, 0x3f, 0x56, 0x85, 0x5f, 0xa6, 0xa0,
	0x10, 0x10, 0x3e, 0x59, 0xea, 0xa0, 0x48, 0xa9, 0xb0, 0x48, 0x61, 0xa5, 0xd2, 0x51, 0xa5, 0x82,
	0xb7, 0x37, 0x73, 0x92, 0xdb, 0xeb, 0x29, 0x0c, 0x23, 0x2b, 0x9c, 0xf3, 0x29, 0x4c, 0xde, 0x84,
	0x33, 0x5c, 0x56, 0xd7, 0x64, 0x6e, 0xf4, 0x3f, 0x72, 0x36, 0x1a, 0x02, 0x43, 0x59, 0x81, 0x99,
	0x80, 0x71, 0xf0, 0xf6, 0x2c, 0x06, 0x6f, 0x4f, 0xc2, 0xfd, 0x53, 0x28, 0xcc, 0xb2, 0x63, 0x9c,
	0xf6, 0xe8, 0xf7, 0x67, 0x11, 0x26, 0xf6, 0xf5, 0x36, 0x4b, 0x14, 0x29, 0xe4, 0x73, 0xce, 0xa7,
	0xe9, 0xfa, 0x47, 0x3d, 0x96, 0x9d, 0x74, 0xa3, 0xdb, 0xe0, 0x48, 0xca, 0x2d, 0xc8, 0x71, 0x16,
	0x28, 0xe4, 0xf5, 0xa0, 0x90, 0x31, 0x4a, 0x72, 0xf1, 0x7e, 0x95, 0x86, 0x02, 0x07, 0x6d, 0xb7,
	0x0e, 0x69, 0x47, 0x25, 0x15, 0x98, 0x11, 0xfe, 0xb5, 0x10, 0xe2, 0xc9, 0x27, 0x32, 0x9d, 0x83,
	0x19, 0x5f, 0xf2, 0x91, 0x45, 0xcf, 0xbb, 0x7b, 0x03, 0x9e, 0x9b, 0xc3, 0xb5, 0x90, 0xf0, 0xe8,
	0xca, 0x20, 0xb9, 0x00, 0x7b, 0x17, 0x26, 0xda, 0xea, 0x1e, 0x6d, 0x5b, 0x25, 0x0d, 0x75, 0xb9,
	0x1a, 0xd1, 0xc5, 0x11, 0xa7, 0x7a, 0x1f, 0xb1, 0xd6, 0xbb, 0xb6, 0x39, 0x68, 0xf0, 0x23, 0x64,
	0x03, 0x40, 0xb5, 0x6d, 0x53, 0xdf, 0xeb, 0xdb, 0xd4, 0x2a, 0x51, 0x24, 0x70, 0x7d, 0x18, 0x81,
	0x65, 0x17, 0xd3, 0x21, 0xe2, 0x3b, 0x2a, 0xdf, 0x81, 0x9c, 0x8f, 0x3e, 0x29, 0x42, 0xfa, 0x31,
	0x1d, 0x70, 0xb3, 0xb0, 0x9f, 0x2c, 0xdc, 0x8e, 0xd4, 0x76, 0x5f, 0xd8, 0xc2, 0x59, 0xdc, 0x4d,
	0xdd, 0x96, 0xe4, 0x6f, 0xc3, 0x74, 0x88, 0xf2, 0x49, 0x8e, 0x2b, 0xdb, 0x30, 0xb3, 0x41, 0x45,
	0xfc, 0x88, 0xf0, 0x09, 0x5e, 0x42, 0x29, 0x7c, 0x09, 0x13, 0x0b, 0xc0, 0xdf, 0x67, 0xe0, 0xac,
	0x53, 0x00, 0x9e, 0x8a, 0x70, 0xd4, 0x5b, 0x17, 0x20, 0x2b, 0x5e, 0x75, 0xab, 0x94, 0xc3, 0xe7,
	0x6b, 0x92, 0x3f, 0xeb, 0x16, 0x3b, 0xdd, 0x33, 0x8d, 0x23, 0x5d, 0xa3, 0x26, 0x3b, 0xed, 0xbc,
	0xb5, 0x20, 0x40, 0xbe, 0x78, 0x2a, 0xf8, 0xe2, 0x29, 0xf4, 0x04, 0x4f, 0x45, 0x9f, 0xe0, 0xdb,
	0x30, 0xa5, 0xd1, 0x7d, 0xb5, 0xdf, 0xb6, 0x9b, 0x3c, 0x39, 0x4c, 0x0f, 0x4b, 0x0e, 0x05, 0x8e,
	0xe8, 0x2c, 0xc9, 0x1c, 0x4c, 0xe8, 0x1d, 0xf5, 0x80, 0x5a, 0xa5, 0x22, 0x8a, 0xca, 0x57, 0x64,
	0x25, 0x14, 0x73, 0x15, 0x2f, 0x64, 0xe2, 0xac, 0x16, 0x1b, 0x7a, 0x5b, 0x31, 0xa1, 0x57, 0x4d,
	0xa0, 0xf3, 0x6a, 0x46, 0x20, 0x0b, 0x16, 0xe7, 0x9d, 0xfb, 0x7f, 0xb0, 0x9c, 0x2c, 0x58, 0xe2,
	0xac, 0xf6, 0x32, 0xc1, 0x12, 0x4b, 0xe7, 0xd5, 0x0c, 0x96, 0xcf, 0x32, 0x70, 0x86, 0x0b, 0x9a,
	0x14, 0x1f, 0xb1, 0x2f, 0x4d, 0x2a, 0xfe, 0xa5, 0xf9, 0x1f, 0x89, 0xa5, 0x6f, 0x85, 0x62, 0xe9,
	0x52, 0xe4, 0xad, 0x8a, 0x0d, 0x9f, 0xe5, 0x98, 0xf0, 0xb9, 0x12, 0x3d, 0xfa, 0x6a, 0x46, 0xcc,
	0xe7, 0x12, 0xc0, 0x6e, 0xaf, 0x6d, 0xa8, 0xda, 0x03, 0x6a, 0xab, 0xcc, 0x91, 0xfb, 0x7a, 0x9b,
	0x36, 0xd1, 0x1f, 0x0e, 0x81, 0x49, 0x06, 0xd8, 0x62, 0x3e, 0x21, 0x90, 0x69, 0xeb, 0xdd, 0xc7,
	0xa2, 0xe0, 0x60, 0xbf, 0x93, 0x43, 0xe3, 0xb6, 0x6b, 0xd4, 0xb3, 0x68, 0x99, 0x79, 0xff, 0xc5,
	0x12, 0x7c, 0xe3, 0xec, 0x7a, 0x0a, 0xa3, 0x28, 0x39, 0xc8, 0xbe, 0xaf, 0x9a, 0xf4, 0xd0, 0xe8,
	0x5b, 0x54, 0x99, 0x81, 0x69, 0x77, 0x71, 0xcf, 0x29, 0xd8, 0xee, 0x42, 0xc1, 0x05, 0x61, 0xc9,
	0x76, 0x23, 0x58, 0xb2, 0xcd, 0x7a, 0x42, 0xba, 0x78, 0xa2, 0x68, 0xfb, 0x75, 0x0a, 0xc6, 0x1f,
	0x9a, 0x1a, 0x35, 0x59, 0x13, 0x6d, 0x98, 0x3c, 0xaa, 0x79, 0x13, 0x8d, 0x6b, 0xa7, 0x80, 0xb4,
	0x6c, 0xd5, 0xee, 0x5b, 0x28, 0xdb, 0x54, 0xfd, 0x9c, 0x47, 0x10, 0xcf, 0x6e, 0xe3, 0x66, 0x83,
	0x23, 0xe1, 0x0d, 0x30, 0x6c, 0xca, 0xeb, 0x75, 0xfc, 0xed, 0x89, 0x94, 0x09, 0x8b, 0x84, 0x14,
	0x7c, 0x65, 0x2e, 0x79, 0x07, 0xf2, 0xb6, 0x61, 0xab, 0x6d, 0x71, 0x11, 0xc6, 0x87, 0x5d, 0x84,
	0x1c, 0xa2, 0xf1, 0x6b, 0x70, 0x29, 0xd0, 0x09, 0x4c, 0xcc, 0x4b, 0x0b, 0x69, 0x7f, 0xb5, 0x9f,
	0xe8, 0x59, 0xff, 0x0c, 0x21, 0x17, 0x98, 0x21, 0x28, 0x9f, 0x48, 0x90, 0x75, 0xa5, 0xf4, 0x97,
	0xfd, 0x52, 0x52, 0xd9, 0xef, 0x75, 0x0e, 0xcc, 0x70, 0xe3, 0xa2, 0x73, 0xf0, 0x5a, 0x8f, 0x74,
	0x52, 0xeb, 0xe1, 0xf7, 0x0a, 0x04, 0xbc, 0xc2, 0x1a, 0x71, 0x94, 0x2a, 0xa1, 0x11, 0x47, 0x1c,
	0xe1, 0xee, 0x8f, 0x25, 0xc8, 0x21, 0xc0, 0x09, 0x9d, 0x51, 0x9d, 0x9e, 0x4e, 0x76, 0xfa, 0x69,
	0x0c, 0x7c, 0x1f, 0x26, 0x1f, 0xf1, 0x04, 0x1a, 0xce, 0xaf, 0x52, 0x24, 0xbf, 0x26, 0x31, 0x52,
	0x96, 0x60, 0x4a, 0x50, 0xe3, 0x5a, 0x26, 0x1e, 0x99, 0x82, 0xbc, 0x38, 0xc2, 0xac, 0xc9, 0x04,
	0x5a, 0xed, 0x5b, 0xb6, 0xd1, 0x71, 0x0e, 0xb7, 0xf8, 0x6f, 0x9f, 0x40, 0x02, 0x34, 0xa2, 0x40,
	0x82, 0xda, 0x09, 0x04, 0x12, 0x47, 0x98, 0x40, 0x95, 0xc7, 0xdc, 0x6d, 0x8e, 0xd1, 0x89, 0x0c,
	0x73, 0x0f, 0x1b, 0x6b, 0xeb, 0x8d, 0xe6, 0xf6, 0xce, 0xf2, 0xce, 0xee, 0x76, 0x73, 0x77, 0x6b,
	0x6d, 0xfd, 0xde, 0xe6, 0xd6, 0xfa, 0x5a, 0x71, 0x8c, 0xcc, 0x40, 0x61, 0xeb, 0xe1, 0x4e, 0x73,
	0x7b, 0x77, 0xe5, 0xc1, 0xe6, 0xce, 0xce, 0xfa, 0x5a, 0x51, 0x22, 0x05, 0xc8, 0x7a, 0xcb, 0x14,
	0x99, 0x84, 0xcc, 0xa3, 0xe5, 0xcd, 0xb5, 0x62, 0x9a, 0xfd, 0xda, 0x5e, 0xdf, 0xda, 0x29, 0x66,
	0x08, 0xc0, 0xc4, 0xea, 0xf2, 0xd6, 0xea, 0xfa, 0xfd, 0xe2, 0x78, 0xfd, 0xd3, 0x0c, 0x4c, 0x8b,
	0x19, 0xfa, 0x36, 0x35, 0x8f, 0xf4, 0x16, 0x25, 0x3f, 0x84, 0x19, 0xa7, 0xcc, 0x14, 0x1b, 0x6b,
	0xe6, 0x80, 0xc4, 0xcc, 0xdc, 0xe5, 0x18, 0x98, 0x72, 0xfe, 0x67, 0x9f, 0xff, 0xed, 0xe3, 0xd4,
	0xac, 0x32, 0x55, 0x13, 0x2a, 0x5a, 0x77, 0x35, 0x73, 0x70, 0x57, 0xaa, 0x90, 0x87, 0x30, 0x15,
	0xa4, 0x3b, 0x32, 0xd1, 0x73, 0x48, 0x74, 0x5a, 0x01, 0x1f, 0x51, 0xa9, 0x42, 0x1a, 0x90, 0xdf,
	0xa0, 0xb6, 0xc0, 0xb2, 0xc8, 0x5c, 0x64, 0x1a, 0xb0, 0xde, 0xe9, 0xd9, 0x03, 0x79, 0x2e, 0x4a,
	0x12, 0x5d, 0x4f, 0x90, 0x6c, 0x9e, 0xf8, 0xc8, 0x92, 0x1f, 0xe1, 0x64, 0x43, 0xb7, 0x29, 0xeb,
	0x38, 0x99, 0xe2, 0xa1, 0x26, 0x54, 0x0e, 0xad, 0x95, 0x45, 0x24, 0x72, 0x5d, 0x51, 0x3c, 0x22,
	0xb5, 0x27, 0x3e, 0x8f, 0x3f, 0xad, 0xf5, 0x2d, 0x6a, 0xba, 0x46, 0x78, 0x1f, 0xc0, 0xa3, 0x9f,
	0x48, 0xfc, 0x06, 0x12, 0xbf, 0xaa, 0x94, 0x13, 0x88, 0x4b, 0x15, 0xf2, 0x01, 0x4c, 0x6e, 0x50,
	0x9b, 0x9d, 0xb2, 0x92, 0xec, 0x2a, 0xbe, 0x3d, 0x28, 0x6f, 0x20, 0xf9, 0x79, 0x92, 0x40, 0xbe,
	0xfe, 0x59, 0x86, 0x4f, 0x61, 0x45, 0x88, 0x18, 0xc2, 0x95, 0xce, 0x6c, 0xd6, 0x1c, 0x90, 0x8b,
	0xe1, 0x1e, 0xc5, 0x3f, 0x79, 0x97, 0xc3, 0xc3, 0x42, 0xa5, 0x8a, 0x9c, 0x17, 0x94, 0xab, 0x43,
	0x39, 0x63, 0xc2, 0x70, 0xcd, 0x76, 0x08, 0x39, 0x1f, 0xd9, 0x93, 0x72, 0xab, 0x20, 0xb7, 0x6b,
	0xca, 0xe5, 0x24, 0x6e, 0x0e, 0x27, 0xdf, 0xa7, 0x03, 0x3f, 0xa7, 0xe8, 0x17, 0x85, 0xa1, 0x9c,
	0xe4, 0x51, 0x38, 0x1d, 0x00, 0x78, 0xdf, 0x74, 0xc8, 0x05, 0x8f, 0x54, 0xe4, 0x4b, 0x8f, 0x3c,
	0x1b, 0xe2, 0x83, 0xde, 0xbb, 0x8e, 0xbc, 0xae, 0x90, 0x24, 0x5e, 0xe4, 0x43, 0x0c, 0x0d, 0xfe,
	0x09, 0xc1, 0xa3, 0x14, 0xfa, 0x34, 0xe4, 0xbf, 0x26, 0xfe, 0x91, 0xbb, 0x52, 0x47, 0x3e, 0x6f,
	0x91, 0x4a, 0x02, 0x9f, 0xda, 0x13, 0x91, 0xf4, 0x9f, 0xd6, 0xff, 0x9e, 0x86, 0xa2, 0x3b, 0xd8,
	0x12, 0x51, 0xf3, 0x89, 0x04, 0xc5, 0xf0, 0xe4, 0x96, 0xf8, 0x0a, 0xce, 0x21, 0x53, 0x5d, 0x79,
	0xd8, 0xb0, 0x4c, 0x59, 0x43, 0xc9, 0xbe, 0xa3, 0xdc, 0x19, 0x2a, 0x99, 0x18, 0x20, 0xea, 0x4c,
	0x3c, 0xff, 0x84, 0xf1, 0x69, 0x0d, 0x5f, 0x49, 0xe6, 0x87, 0x5f, 0x48, 0x40, 0xa2, 0x23, 0x6b,
	0x72, 0x35, 0xe8, 0x90, 0xd8, 0x81, 0xb6, 0x7c, 0x61, 0x88, 0x68, 0xe8, 0xa0, 0x65, 0x14, 0xef,
	0x5d, 0xf2, 0xf2, 0xe2, 0x91, 0xdf, 0x4a, 0x30, 0x1b, 0x33, 0x2c, 0x26, 0xd7, 0xc2, 0x61, 0x79,
	0x32, 0xc3, 0xfd, 0x00, 0x25, 0xfb, 0xbe, 0x7c, 0xef, 0xa5, 0x25, 0xab, 0x3d, 0xf1, 0x7a, 0xb4,
	0xa7, 0x77, 0xa5, 0x4a, 0xfd, 0x0f, 0x13, 0xf8, 0x16, 0x63, 0xfb, 0xc5, 0xfd, 0xfd, 0x04, 0xe6,
	0x02, 0xf3, 0x0a, 0xa7, 0x2d, 0x63, 0xd9, 0xe2, 0xb5, 0x21, 0xc3, 0x34, 0x79, 0xd8, 0x86, 0x52,
	0x43, 0x89, 0x6f, 0x28, 0xd7, 0x86, 0x07, 0x21, 0x22, 0xba, 0x19, 0xc3, 0x86, 0xd9, 0x18, 0xe6,
	0x2f, 0xc1, 0xf9, 0x4d, 0xe4, 0xfc, 0xba, 0x32, 0x9f, 0xc8, 0x59, 0xaa, 0x90, 0x7d, 0xc8, 0x3b,
	0x5c, 0x9d, 0x16, 0x81, 0x9c, 0x8d, 0x6b, 0x1a, 0xe4, 0x58, 0xe8, 0x08, 0x59, 0xaa, 0x8f, 0xc8,
	0x8c, 0x4f, 0x0f, 0x0a, 0x01, 0xed, 0x48, 0xf9, 0xeb, 0x67, 0x44, 0x72, 0xb4, 0x72, 0x55, 0xde,
	0x42, 0x7e, 0x6f, 0x28, 0x57, 0x86, 0xf2, 0xe3, 0x2e, 0xb6, 0x38, 0xc7, 0xc0, 0x3c, 0xc1, 0xcf,
	0x31, 0x6e, 0xd0, 0xf0, 0x35, 0x1c, 0xe5, 0xd1, 0x38, 0x1a, 0x90, 0xf7, 0xcf, 0xc0, 0xc9, 0xa5,
	0xe0, 0x85, 0x0c, 0xcd, 0xc6, 0xe5, 0x73, 0x11, 0x7e, 0x78, 0x09, 0xf9, 0x13, 0x4a, 0x92, 0x79,
	0x12, 0x1b, 0xc0, 0x9b, 0x99, 0xfa, 0x13, 0x72, 0x64, 0x92, 0x1a, 0xa7, 0xdc, 0x2d, 0x64, 0xf4,
	0x36, 0xa9, 0x26, 0x32, 0x0a, 0xdc, 0x9d, 0x3a, 0x81, 0xa2, 0xdb, 0xaa, 0xf1, 0x9b, 0x53, 0x7f,
	0x96, 0x86, 0xbc, 0x53, 0x04, 0xf2, 0xab, 0xd4, 0x11, 0xef, 0x9f, 0xd3, 0xc0, 0x85, 0x6b, 0x7e,
	0x39, 0x0c, 0x50, 0xde, 0x43, 0x69, 0x6e, 0x29, 0x4b, 0xa3, 0x27, 0xed, 0x1a, 0xb6, 0x03, 0x68,
	0xfa, 0x8f, 0xc4, 0x23, 0x38, 0x2a, 0xbb, 0x0d, 0x64, 0xb7, 0x2c, 0xbf, 0x77, 0x62, 0x76, 0xb5,
	0x27, 0xa2, 0x2b, 0x61, 0x69, 0x84, 0xf4, 0x21, 0xb7, 0xaa, 0x76, 0x5b, 0xb4, 0x3d, 0x2a, 0x67,
	0xfe, 0x06, 0x54, 0x4e, 0xc5, 0x99, 0xfc, 0x18, 0xb2, 0x1b, 0xd4, 0x46, 0x8a, 0x16, 0x09, 0xb7,
	0x3f, 0x4e, 0x25, 0x2f, 0x87, 0x1b, 0xd9, 0x11, 0x1f, 0x61, 0x87, 0x59, 0xfd, 0x4b, 0x09, 0xa6,
	0x45, 0xe3, 0x21, 0xbc, 0x7a, 0x20, 0xca, 0x28, 0xb7, 0x25, 0x22, 0x81, 0xb8, 0x42, 0x98, 0x1c,
	0x03, 0x1b, 0xa1, 0xea, 0x14, 0x6d, 0x14, 0xfa, 0xb3, 0x8d, 0x95, 0xb2, 0x38, 0x6d, 0x91, 0x52,
	0x94, 0x24, 0x57, 0x72, 0x2e, 0xba, 0x83, 0x7a, 0xf2, 0xe4, 0x44, 0x46, 0x60, 0x88, 0xaa, 0x8a,
	0x96, 0x26, 0xa2, 0xaa, 0xdb, 0x6c, 0xf9, 0xd4, 0x12, 0x30, 0x39, 0x06, 0x36, 0x82, 0xaa, 0xa2,
	0x41, 0xf3, 0xa9, 0x2a, 0x4e, 0x07, 0x54, 0x0d, 0x76, 0x66, 0x7e, 0x55, 0xfd, 0x0d, 0xd8, 0x08,
	0xaa, 0xba, 0x0c, 0x57, 0xb4, 0x67, 0xcf, 0xcb, 0x63, 0x5f, 0x3c, 0x2f, 0x8f, 0x7d, 0xf5, 0xbc,
	0x2c, 0xfd, 0xf4, 0xb8, 0x2c, 0xfd, 0xee, 0xb8, 0x2c, 0xfd, 0xf9, 0xb8, 0x2c, 0x3d, 0x3b, 0x2e,
	0x4b, 0x7f, 0x3d, 0x2e, 0x4b, 0x5f, 0x1e, 0x97, 0xc7, 0xbe, 0x3a, 0x2e, 0x4b, 0x3f, 0x7f, 0x51,
	0x1e, 0x7b, 0xf6, 0xa2, 0x3c, 0xf6, 0xc5, 0x8b, 0xf2, 0xd8, 0x07, 0xd5, 0x03, 0xdd, 0x3e, 0xec,
	0xef, 0x55, 0x5b, 0x46, 0xa7, 0xb6, 0xdf, 0x36, 0x7e, 0xd2, 0xef, 0xd5, 0x0e, 0xa9, 0xaa, 0xb5,
	0xa9, 0x65, 0xa9, 0x3d, 0xdd, 0xaa, 0x1d, 0x18, 0x8b, 0x96, 0xf6, 0xd8, 0xf9, 0x3b, 0x57, 0xed,
	0x68, 0x69, 0x6f, 0x02, 0x1b, 0x9a, 0x9b, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x09, 0xfd, 0xf7,
	0x71, 0xe4, 0x25, 0x00, 0x00,
}

func (x OrderStatus) String() string {
	s, ok := OrderStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Merchant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Merchant)
	if !ok {
		that2, ok := that.(Merchant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MerchantList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MerchantList)
	if !ok {
		that2, ok := that.(MerchantList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.InvitedById != that1.InvitedById {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Thumbnail != that1.Thumbnail {
		return false
	}
	return true
}
func (this *UserList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserList)
	if !ok {
		that2, ok := that.(UserList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListStoresRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListStoresRequest)
	if !ok {
		that2, ok := that.(ListStoresRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *GetStoreRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetStoreRequest)
	if !ok {
		that2, ok := that.(GetStoreRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CreateStoreRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateStoreRequest)
	if !ok {
		that2, ok := that.(CreateStoreRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *UpdateStoreRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateStoreRequest)
	if !ok {
		that2, ok := that.(UpdateStoreRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.InventoryIds) != len(that1.InventoryIds) {
		return false
	}
	for i := range this.InventoryIds {
		if this.InventoryIds[i] != that1.InventoryIds[i] {
			return false
		}
	}
	return true
}
func (this *Store) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Store)
	if !ok {
		that2, ok := that.(Store)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.InventoryIds) != len(that1.InventoryIds) {
		return false
	}
	for i := range this.InventoryIds {
		if this.InventoryIds[i] != that1.InventoryIds[i] {
			return false
		}
	}
	return true
}
func (this *StoreDetails) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreDetails)
	if !ok {
		that2, ok := that.(StoreDetails)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.ProductCounter != that1.ProductCounter {
		return false
	}
	if this.ItemCounter != that1.ItemCounter {
		return false
	}
	if len(this.InventoryIds) != len(that1.InventoryIds) {
		return false
	}
	for i := range this.InventoryIds {
		if this.InventoryIds[i] != that1.InventoryIds[i] {
			return false
		}
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *StoreList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreList)
	if !ok {
		that2, ok := that.(StoreList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListInventoryItemsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListInventoryItemsRequest)
	if !ok {
		that2, ok := that.(ListInventoryItemsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.InventoryId != that1.InventoryId {
		return false
	}
	return true
}
func (this *AddInventoryItemRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddInventoryItemRequest)
	if !ok {
		that2, ok := that.(AddInventoryItemRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.InventoryId != that1.InventoryId {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *UpdateInventoryItemRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateInventoryItemRequest)
	if !ok {
		that2, ok := that.(UpdateInventoryItemRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.InventoryId != that1.InventoryId {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *InventoryItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InventoryItem)
	if !ok {
		that2, ok := that.(InventoryItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.InventoryId != that1.InventoryId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	return true
}
func (this *InventoryItemList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InventoryItemList)
	if !ok {
		that2, ok := that.(InventoryItemList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListProductsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListProductsRequest)
	if !ok {
		that2, ok := that.(ListProductsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.Filter) != len(that1.Filter) {
		return false
	}
	for i := range this.Filter {
		if !this.Filter[i].Equal(that1.Filter[i]) {
			return false
		}
	}
	return true
}
func (this *ProductList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductList)
	if !ok {
		that2, ok := that.(ProductList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ProductSchema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductSchema)
	if !ok {
		that2, ok := that.(ProductSchema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductSchemaId != that1.ProductSchemaId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.CreatedBy.Equal(that1.CreatedBy) {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *GetProductRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProductRequest)
	if !ok {
		that2, ok := that.(GetProductRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CreateProductRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateProductRequest)
	if !ok {
		that2, ok := that.(CreateProductRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.StoreIds) != len(that1.StoreIds) {
		return false
	}
	for i := range this.StoreIds {
		if this.StoreIds[i] != that1.StoreIds[i] {
			return false
		}
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.DefaultAmount.Equal(that1.DefaultAmount) {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if this.Images[i] != that1.Images[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *UpdateProductRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateProductRequest)
	if !ok {
		that2, ok := that.(UpdateProductRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.StoreIds) != len(that1.StoreIds) {
		return false
	}
	for i := range this.StoreIds {
		if this.StoreIds[i] != that1.StoreIds[i] {
			return false
		}
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.DefaultAmount.Equal(that1.DefaultAmount) {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if this.Images[i] != that1.Images[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.ProductSchemaId != that1.ProductSchemaId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.StoreIds) != len(that1.StoreIds) {
		return false
	}
	for i := range this.StoreIds {
		if this.StoreIds[i] != that1.StoreIds[i] {
			return false
		}
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.DefaultAmount.Equal(that1.DefaultAmount) {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if this.Images[i] != that1.Images[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *UploadMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadMeta)
	if !ok {
		that2, ok := that.(UploadMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if this.Link != that1.Link {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *Warehouse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Warehouse)
	if !ok {
		that2, ok := that.(Warehouse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *WarehouseFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WarehouseFilter)
	if !ok {
		that2, ok := that.(WarehouseFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *WarehouseList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WarehouseList)
	if !ok {
		that2, ok := that.(WarehouseList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Note != that1.Note {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if !this.TotalAmount.Equal(that1.TotalAmount) {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *OrderItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderItem)
	if !ok {
		that2, ok := that.(OrderItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *OrderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderList)
	if !ok {
		that2, ok := that.(OrderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *OrderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderFilter)
	if !ok {
		that2, ok := that.(OrderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if len(this.Status) != len(that1.Status) {
		return false
	}
	for i := range this.Status {
		if this.Status[i] != that1.Status[i] {
			return false
		}
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *Provider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Provider)
	if !ok {
		that2, ok := that.(Provider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *ProviderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderFilter)
	if !ok {
		that2, ok := that.(ProviderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *ProviderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProviderList)
	if !ok {
		that2, ok := that.(ProviderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Customer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Customer)
	if !ok {
		that2, ok := that.(Customer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CustomerFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomerFilter)
	if !ok {
		that2, ok := that.(CustomerFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *CustomerList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomerList)
	if !ok {
		that2, ok := that.(CustomerList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Merchant) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Merchant{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MerchantList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.MerchantList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1.User{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "InvitedById: "+fmt.Sprintf("%#v", this.InvitedById)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.UserList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListStoresRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.ListStoresRequest{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetStoreRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.GetStoreRequest{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateStoreRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1.CreateStoreRequest{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateStoreRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1.UpdateStoreRequest{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "InventoryIds: "+fmt.Sprintf("%#v", this.InventoryIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Store) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&v1.Store{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "InventoryIds: "+fmt.Sprintf("%#v", this.InventoryIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreDetails) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&v1.StoreDetails{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "ProductCounter: "+fmt.Sprintf("%#v", this.ProductCounter)+",\n")
	s = append(s, "ItemCounter: "+fmt.Sprintf("%#v", this.ItemCounter)+",\n")
	s = append(s, "InventoryIds: "+fmt.Sprintf("%#v", this.InventoryIds)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.StoreList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListInventoryItemsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.ListInventoryItemsRequest{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "InventoryId: "+fmt.Sprintf("%#v", this.InventoryId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddInventoryItemRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1.AddInventoryItemRequest{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "InventoryId: "+fmt.Sprintf("%#v", this.InventoryId)+",\n")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateInventoryItemRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1.UpdateInventoryItemRequest{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "InventoryId: "+fmt.Sprintf("%#v", this.InventoryId)+",\n")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InventoryItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&v1.InventoryItem{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "InventoryId: "+fmt.Sprintf("%#v", this.InventoryId)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InventoryItemList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.InventoryItemList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListProductsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.ListProductsRequest{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.ProductList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductSchema) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&v1.ProductSchema{")
	s = append(s, "ProductSchemaId: "+fmt.Sprintf("%#v", this.ProductSchemaId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.CreatedBy != nil {
		s = append(s, "CreatedBy: "+fmt.Sprintf("%#v", this.CreatedBy)+",\n")
	}
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProductRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.GetProductRequest{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateProductRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&v1.CreateProductRequest{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreIds: "+fmt.Sprintf("%#v", this.StoreIds)+",\n")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.DefaultAmount != nil {
		s = append(s, "DefaultAmount: "+fmt.Sprintf("%#v", this.DefaultAmount)+",\n")
	}
	s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateProductRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&v1.UpdateProductRequest{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreIds: "+fmt.Sprintf("%#v", this.StoreIds)+",\n")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.DefaultAmount != nil {
		s = append(s, "DefaultAmount: "+fmt.Sprintf("%#v", this.DefaultAmount)+",\n")
	}
	s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&v1.Product{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "ProductSchemaId: "+fmt.Sprintf("%#v", this.ProductSchemaId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreIds: "+fmt.Sprintf("%#v", this.StoreIds)+",\n")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.DefaultAmount != nil {
		s = append(s, "DefaultAmount: "+fmt.Sprintf("%#v", this.DefaultAmount)+",\n")
	}
	s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.UploadMeta{")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "Link: "+fmt.Sprintf("%#v", this.Link)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Warehouse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.Warehouse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WarehouseFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.WarehouseFilter{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WarehouseList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.WarehouseList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&v1.Order{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Note: "+fmt.Sprintf("%#v", this.Note)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	if this.TotalAmount != nil {
		s = append(s, "TotalAmount: "+fmt.Sprintf("%#v", this.TotalAmount)+",\n")
	}
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.OrderItem{")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&v1.OrderFilter{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Provider) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Provider{")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.ProviderFilter{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProviderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.ProviderList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Customer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.Customer{")
	s = append(s, "CustomerId: "+fmt.Sprintf("%#v", this.CustomerId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CustomerFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.CustomerFilter{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CustomerList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&v1.CustomerList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAdminApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MerchantServiceClient is the client API for MerchantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MerchantServiceClient interface {
	// CreateMerchantDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the merchant
	CreateMerchantDry(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error)
	// CreateMerchant creates a merchant in the database and returns the object
	// back with populated data
	CreateMerchant(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error)
	// GetMerchants returns a list of merchants the user has access to
	GetMerchants(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MerchantList, error)
	// InviteUserDry validates the provided user for existence. correct email,
	// and other required fields by user invitation process
	InviteUserDry(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// InviteUser creates a user account for the user in case it didn't exist before.
	// Otherwise it invites the user into the merchant
	InviteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// GetUsers returns all users present in the merchant
	GetUsers(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*UserList, error)
}

type merchantServiceClient struct {
	cc *grpc.ClientConn
}

func NewMerchantServiceClient(cc *grpc.ClientConn) MerchantServiceClient {
	return &merchantServiceClient{cc}
}

func (c *merchantServiceClient) CreateMerchantDry(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error) {
	out := new(Merchant)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/CreateMerchantDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) CreateMerchant(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*Merchant, error) {
	out := new(Merchant)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/CreateMerchant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) GetMerchants(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*MerchantList, error) {
	out := new(MerchantList)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/GetMerchants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) InviteUserDry(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/InviteUserDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) InviteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/InviteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) GetUsers(ctx context.Context, in *Merchant, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := c.cc.Invoke(ctx, "/admin.v1.MerchantService/GetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MerchantServiceServer is the server API for MerchantService service.
type MerchantServiceServer interface {
	// CreateMerchantDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the merchant
	CreateMerchantDry(context.Context, *Merchant) (*Merchant, error)
	// CreateMerchant creates a merchant in the database and returns the object
	// back with populated data
	CreateMerchant(context.Context, *Merchant) (*Merchant, error)
	// GetMerchants returns a list of merchants the user has access to
	GetMerchants(context.Context, *empty.Empty) (*MerchantList, error)
	// InviteUserDry validates the provided user for existence. correct email,
	// and other required fields by user invitation process
	InviteUserDry(context.Context, *User) (*User, error)
	// InviteUser creates a user account for the user in case it didn't exist before.
	// Otherwise it invites the user into the merchant
	InviteUser(context.Context, *User) (*User, error)
	// GetUsers returns all users present in the merchant
	GetUsers(context.Context, *Merchant) (*UserList, error)
}

// UnimplementedMerchantServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMerchantServiceServer struct {
}

func (*UnimplementedMerchantServiceServer) CreateMerchantDry(ctx context.Context, req *Merchant) (*Merchant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMerchantDry not implemented")
}
func (*UnimplementedMerchantServiceServer) CreateMerchant(ctx context.Context, req *Merchant) (*Merchant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMerchant not implemented")
}
func (*UnimplementedMerchantServiceServer) GetMerchants(ctx context.Context, req *empty.Empty) (*MerchantList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerchants not implemented")
}
func (*UnimplementedMerchantServiceServer) InviteUserDry(ctx context.Context, req *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteUserDry not implemented")
}
func (*UnimplementedMerchantServiceServer) InviteUser(ctx context.Context, req *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteUser not implemented")
}
func (*UnimplementedMerchantServiceServer) GetUsers(ctx context.Context, req *Merchant) (*UserList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}

func RegisterMerchantServiceServer(s *grpc.Server, srv MerchantServiceServer) {
	s.RegisterService(&_MerchantService_serviceDesc, srv)
}

func _MerchantService_CreateMerchantDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).CreateMerchantDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/CreateMerchantDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).CreateMerchantDry(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_CreateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/CreateMerchant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_GetMerchants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).GetMerchants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/GetMerchants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).GetMerchants(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_InviteUserDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).InviteUserDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/InviteUserDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).InviteUserDry(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_InviteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).InviteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/InviteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).InviteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Merchant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.MerchantService/GetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).GetUsers(ctx, req.(*Merchant))
	}
	return interceptor(ctx, in, info, handler)
}

var _MerchantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.MerchantService",
	HandlerType: (*MerchantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMerchantDry",
			Handler:    _MerchantService_CreateMerchantDry_Handler,
		},
		{
			MethodName: "CreateMerchant",
			Handler:    _MerchantService_CreateMerchant_Handler,
		},
		{
			MethodName: "GetMerchants",
			Handler:    _MerchantService_GetMerchants_Handler,
		},
		{
			MethodName: "InviteUserDry",
			Handler:    _MerchantService_InviteUserDry_Handler,
		},
		{
			MethodName: "InviteUser",
			Handler:    _MerchantService_InviteUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _MerchantService_GetUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// StoreServiceClient is the client API for StoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreServiceClient interface {
	// CreateStoreDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the store
	// for the particular merchant
	CreateStoreDry(ctx context.Context, in *CreateStoreRequest, opts ...grpc.CallOption) (*Store, error)
	// Create store creates the store for the particular merchant and returns
	// the store object back to the caller
	CreateStore(ctx context.Context, in *CreateStoreRequest, opts ...grpc.CallOption) (*Store, error)
	// Update store creates the store for the particular merchant and returns
	// the store object back to the caller
	UpdateStore(ctx context.Context, in *UpdateStoreRequest, opts ...grpc.CallOption) (*Store, error)
	// Loads all stores from given merchant
	ListStores(ctx context.Context, in *ListStoresRequest, opts ...grpc.CallOption) (*StoreList, error)
	// Loads single store from a given merchant
	GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*StoreDetails, error)
}

type storeServiceClient struct {
	cc *grpc.ClientConn
}

func NewStoreServiceClient(cc *grpc.ClientConn) StoreServiceClient {
	return &storeServiceClient{cc}
}

func (c *storeServiceClient) CreateStoreDry(ctx context.Context, in *CreateStoreRequest, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/CreateStoreDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) CreateStore(ctx context.Context, in *CreateStoreRequest, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/CreateStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) UpdateStore(ctx context.Context, in *UpdateStoreRequest, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/UpdateStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) ListStores(ctx context.Context, in *ListStoresRequest, opts ...grpc.CallOption) (*StoreList, error) {
	out := new(StoreList)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/ListStores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServiceClient) GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*StoreDetails, error) {
	out := new(StoreDetails)
	err := c.cc.Invoke(ctx, "/admin.v1.StoreService/GetStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoreServiceServer is the server API for StoreService service.
type StoreServiceServer interface {
	// CreateStoreDry runs validation on the server side and returns
	// errors that need to be corrected to successfully create the store
	// for the particular merchant
	CreateStoreDry(context.Context, *CreateStoreRequest) (*Store, error)
	// Create store creates the store for the particular merchant and returns
	// the store object back to the caller
	CreateStore(context.Context, *CreateStoreRequest) (*Store, error)
	// Update store creates the store for the particular merchant and returns
	// the store object back to the caller
	UpdateStore(context.Context, *UpdateStoreRequest) (*Store, error)
	// Loads all stores from given merchant
	ListStores(context.Context, *ListStoresRequest) (*StoreList, error)
	// Loads single store from a given merchant
	GetStore(context.Context, *GetStoreRequest) (*StoreDetails, error)
}

// UnimplementedStoreServiceServer can be embedded to have forward compatible implementations.
type UnimplementedStoreServiceServer struct {
}

func (*UnimplementedStoreServiceServer) CreateStoreDry(ctx context.Context, req *CreateStoreRequest) (*Store, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStoreDry not implemented")
}
func (*UnimplementedStoreServiceServer) CreateStore(ctx context.Context, req *CreateStoreRequest) (*Store, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStore not implemented")
}
func (*UnimplementedStoreServiceServer) UpdateStore(ctx context.Context, req *UpdateStoreRequest) (*Store, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStore not implemented")
}
func (*UnimplementedStoreServiceServer) ListStores(ctx context.Context, req *ListStoresRequest) (*StoreList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStores not implemented")
}
func (*UnimplementedStoreServiceServer) GetStore(ctx context.Context, req *GetStoreRequest) (*StoreDetails, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStore not implemented")
}

func RegisterStoreServiceServer(s *grpc.Server, srv StoreServiceServer) {
	s.RegisterService(&_StoreService_serviceDesc, srv)
}

func _StoreService_CreateStoreDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).CreateStoreDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/CreateStoreDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).CreateStoreDry(ctx, req.(*CreateStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_CreateStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).CreateStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/CreateStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).CreateStore(ctx, req.(*CreateStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_UpdateStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).UpdateStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/UpdateStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).UpdateStore(ctx, req.(*UpdateStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_ListStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).ListStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/ListStores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).ListStores(ctx, req.(*ListStoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreService_GetStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).GetStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.StoreService/GetStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).GetStore(ctx, req.(*GetStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.StoreService",
	HandlerType: (*StoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStoreDry",
			Handler:    _StoreService_CreateStoreDry_Handler,
		},
		{
			MethodName: "CreateStore",
			Handler:    _StoreService_CreateStore_Handler,
		},
		{
			MethodName: "UpdateStore",
			Handler:    _StoreService_UpdateStore_Handler,
		},
		{
			MethodName: "ListStores",
			Handler:    _StoreService_ListStores_Handler,
		},
		{
			MethodName: "GetStore",
			Handler:    _StoreService_GetStore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// InventoryServiceClient is the client API for InventoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InventoryServiceClient interface {
	// Adds an inventory item into the inventory of a merchant.
	AddInventoryItem(ctx context.Context, in *AddInventoryItemRequest, opts ...grpc.CallOption) (*InventoryItem, error)
	// Loads all items from given inventory.
	ListInventoryItems(ctx context.Context, in *ListInventoryItemsRequest, opts ...grpc.CallOption) (*InventoryItemList, error)
	// Updates data stored in inventory Firestore collection
	UpdateInventoryItem(ctx context.Context, in *UpdateInventoryItemRequest, opts ...grpc.CallOption) (*InventoryItem, error)
}

type inventoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewInventoryServiceClient(cc *grpc.ClientConn) InventoryServiceClient {
	return &inventoryServiceClient{cc}
}

func (c *inventoryServiceClient) AddInventoryItem(ctx context.Context, in *AddInventoryItemRequest, opts ...grpc.CallOption) (*InventoryItem, error) {
	out := new(InventoryItem)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/AddInventoryItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) ListInventoryItems(ctx context.Context, in *ListInventoryItemsRequest, opts ...grpc.CallOption) (*InventoryItemList, error) {
	out := new(InventoryItemList)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/ListInventoryItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) UpdateInventoryItem(ctx context.Context, in *UpdateInventoryItemRequest, opts ...grpc.CallOption) (*InventoryItem, error) {
	out := new(InventoryItem)
	err := c.cc.Invoke(ctx, "/admin.v1.InventoryService/UpdateInventoryItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServiceServer is the server API for InventoryService service.
type InventoryServiceServer interface {
	// Adds an inventory item into the inventory of a merchant.
	AddInventoryItem(context.Context, *AddInventoryItemRequest) (*InventoryItem, error)
	// Loads all items from given inventory.
	ListInventoryItems(context.Context, *ListInventoryItemsRequest) (*InventoryItemList, error)
	// Updates data stored in inventory Firestore collection
	UpdateInventoryItem(context.Context, *UpdateInventoryItemRequest) (*InventoryItem, error)
}

// UnimplementedInventoryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInventoryServiceServer struct {
}

func (*UnimplementedInventoryServiceServer) AddInventoryItem(ctx context.Context, req *AddInventoryItemRequest) (*InventoryItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInventoryItem not implemented")
}
func (*UnimplementedInventoryServiceServer) ListInventoryItems(ctx context.Context, req *ListInventoryItemsRequest) (*InventoryItemList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInventoryItems not implemented")
}
func (*UnimplementedInventoryServiceServer) UpdateInventoryItem(ctx context.Context, req *UpdateInventoryItemRequest) (*InventoryItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInventoryItem not implemented")
}

func RegisterInventoryServiceServer(s *grpc.Server, srv InventoryServiceServer) {
	s.RegisterService(&_InventoryService_serviceDesc, srv)
}

func _InventoryService_AddInventoryItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInventoryItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).AddInventoryItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/AddInventoryItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).AddInventoryItem(ctx, req.(*AddInventoryItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_ListInventoryItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInventoryItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).ListInventoryItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/ListInventoryItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).ListInventoryItems(ctx, req.(*ListInventoryItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_UpdateInventoryItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInventoryItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).UpdateInventoryItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.InventoryService/UpdateInventoryItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).UpdateInventoryItem(ctx, req.(*UpdateInventoryItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InventoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.InventoryService",
	HandlerType: (*InventoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddInventoryItem",
			Handler:    _InventoryService_AddInventoryItem_Handler,
		},
		{
			MethodName: "ListInventoryItems",
			Handler:    _InventoryService_ListInventoryItems_Handler,
		},
		{
			MethodName: "UpdateInventoryItem",
			Handler:    _InventoryService_UpdateInventoryItem_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// ProductServiceClient is the client API for ProductService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProductServiceClient interface {
	// CreateProductSchemaDry validates provided product schema and returns a list
	// of errors or the product schema on success
	CreateProductSchemaDry(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error)
	// CreateProductSchema creates the product schema in the system
	CreateProductSchema(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error)
	// CreateUpload creates an upload link for the merchant gallery
	CreateUpload(ctx context.Context, in *UploadMeta, opts ...grpc.CallOption) (*UploadMeta, error)
	// CreateProduct creates a product in the firestore for a particular merchant
	CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*Product, error)
	// UpdateProduct updates a product in the firestore for a particular merchant
	UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*Product, error)
	// Returns all products assigned to a particular merchant
	ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ProductList, error)
	// Loads single product from a given merchant
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error)
}

type productServiceClient struct {
	cc *grpc.ClientConn
}

func NewProductServiceClient(cc *grpc.ClientConn) ProductServiceClient {
	return &productServiceClient{cc}
}

func (c *productServiceClient) CreateProductSchemaDry(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error) {
	out := new(ProductSchema)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/CreateProductSchemaDry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) CreateProductSchema(ctx context.Context, in *ProductSchema, opts ...grpc.CallOption) (*ProductSchema, error) {
	out := new(ProductSchema)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/CreateProductSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) CreateUpload(ctx context.Context, in *UploadMeta, opts ...grpc.CallOption) (*UploadMeta, error) {
	out := new(UploadMeta)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/CreateUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/CreateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/UpdateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ProductList, error) {
	out := new(ProductList)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/ListProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, "/admin.v1.ProductService/GetProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServiceServer is the server API for ProductService service.
type ProductServiceServer interface {
	// CreateProductSchemaDry validates provided product schema and returns a list
	// of errors or the product schema on success
	CreateProductSchemaDry(context.Context, *ProductSchema) (*ProductSchema, error)
	// CreateProductSchema creates the product schema in the system
	CreateProductSchema(context.Context, *ProductSchema) (*ProductSchema, error)
	// CreateUpload creates an upload link for the merchant gallery
	CreateUpload(context.Context, *UploadMeta) (*UploadMeta, error)
	// CreateProduct creates a product in the firestore for a particular merchant
	CreateProduct(context.Context, *CreateProductRequest) (*Product, error)
	// UpdateProduct updates a product in the firestore for a particular merchant
	UpdateProduct(context.Context, *UpdateProductRequest) (*Product, error)
	// Returns all products assigned to a particular merchant
	ListProducts(context.Context, *ListProductsRequest) (*ProductList, error)
	// Loads single product from a given merchant
	GetProduct(context.Context, *GetProductRequest) (*Product, error)
}

// UnimplementedProductServiceServer can be embedded to have forward compatible implementations.
type UnimplementedProductServiceServer struct {
}

func (*UnimplementedProductServiceServer) CreateProductSchemaDry(ctx context.Context, req *ProductSchema) (*ProductSchema, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductSchemaDry not implemented")
}
func (*UnimplementedProductServiceServer) CreateProductSchema(ctx context.Context, req *ProductSchema) (*ProductSchema, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductSchema not implemented")
}
func (*UnimplementedProductServiceServer) CreateUpload(ctx context.Context, req *UploadMeta) (*UploadMeta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUpload not implemented")
}
func (*UnimplementedProductServiceServer) CreateProduct(ctx context.Context, req *CreateProductRequest) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (*UnimplementedProductServiceServer) UpdateProduct(ctx context.Context, req *UpdateProductRequest) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProduct not implemented")
}
func (*UnimplementedProductServiceServer) ListProducts(ctx context.Context, req *ListProductsRequest) (*ProductList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProducts not implemented")
}
func (*UnimplementedProductServiceServer) GetProduct(ctx context.Context, req *GetProductRequest) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}

func RegisterProductServiceServer(s *grpc.Server, srv ProductServiceServer) {
	s.RegisterService(&_ProductService_serviceDesc, srv)
}

func _ProductService_CreateProductSchemaDry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateProductSchemaDry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/CreateProductSchemaDry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateProductSchemaDry(ctx, req.(*ProductSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_CreateProductSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductSchema)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateProductSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/CreateProductSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateProductSchema(ctx, req.(*ProductSchema))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_CreateUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/CreateUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateUpload(ctx, req.(*UploadMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/CreateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateProduct(ctx, req.(*CreateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_UpdateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).UpdateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/UpdateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).UpdateProduct(ctx, req.(*UpdateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/ListProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).ListProducts(ctx, req.(*ListProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProductService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProductService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.ProductService",
	HandlerType: (*ProductServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProductSchemaDry",
			Handler:    _ProductService_CreateProductSchemaDry_Handler,
		},
		{
			MethodName: "CreateProductSchema",
			Handler:    _ProductService_CreateProductSchema_Handler,
		},
		{
			MethodName: "CreateUpload",
			Handler:    _ProductService_CreateUpload_Handler,
		},
		{
			MethodName: "CreateProduct",
			Handler:    _ProductService_CreateProduct_Handler,
		},
		{
			MethodName: "UpdateProduct",
			Handler:    _ProductService_UpdateProduct_Handler,
		},
		{
			MethodName: "ListProducts",
			Handler:    _ProductService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _ProductService_GetProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// WarehouseServiceClient is the client API for WarehouseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WarehouseServiceClient interface {
}

type warehouseServiceClient struct {
	cc *grpc.ClientConn
}

func NewWarehouseServiceClient(cc *grpc.ClientConn) WarehouseServiceClient {
	return &warehouseServiceClient{cc}
}

// WarehouseServiceServer is the server API for WarehouseService service.
type WarehouseServiceServer interface {
}

// UnimplementedWarehouseServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWarehouseServiceServer struct {
}

func RegisterWarehouseServiceServer(s *grpc.Server, srv WarehouseServiceServer) {
	s.RegisterService(&_WarehouseService_serviceDesc, srv)
}

var _WarehouseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.WarehouseService",
	HandlerType: (*WarehouseServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "v1/admin_api.proto",
}

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderServiceClient interface {
	// CreateOrder creates an order for the particular user in the store
	CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// UpdateOrder update an attributes in order
	UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// CancelOrder set status of order to cancel
	CancelOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) CreateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/CreateOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) UpdateOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/UpdateOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) CancelOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error) {
	out := new(OrderList)
	err := c.cc.Invoke(ctx, "/admin.v1.OrderService/GetOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
type OrderServiceServer interface {
	// CreateOrder creates an order for the particular user in the store
	CreateOrder(context.Context, *Order) (*Order, error)
	// UpdateOrder update an attributes in order
	UpdateOrder(context.Context, *Order) (*Order, error)
	// CancelOrder set status of order to cancel
	CancelOrder(context.Context, *Order) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(context.Context, *OrderFilter) (*OrderList, error)
}

// UnimplementedOrderServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOrderServiceServer struct {
}

func (*UnimplementedOrderServiceServer) CreateOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (*UnimplementedOrderServiceServer) UpdateOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrder not implemented")
}
func (*UnimplementedOrderServiceServer) CancelOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedOrderServiceServer) GetOrders(ctx context.Context, req *OrderFilter) (*OrderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrders not implemented")
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/CreateOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_UpdateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).UpdateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/UpdateOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).UpdateOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CancelOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.OrderService/GetOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrders(ctx, req.(*OrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrder",
			Handler:    _OrderService_CreateOrder_Handler,
		},
		{
			MethodName: "UpdateOrder",
			Handler:    _OrderService_UpdateOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _OrderService_CancelOrder_Handler,
		},
		{
			MethodName: "GetOrders",
			Handler:    _OrderService_GetOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// ProviderServiceClient is the client API for ProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProviderServiceClient interface {
	// CreateProvider creates a provider for the particular merchant
	CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Provider, error)
	// GetProviders returns all providers that the user has access to
	GetProviders(ctx context.Context, in *ProviderFilter, opts ...grpc.CallOption) (*ProviderList, error)
}

type providerServiceClient struct {
	cc *grpc.ClientConn
}

func NewProviderServiceClient(cc *grpc.ClientConn) ProviderServiceClient {
	return &providerServiceClient{cc}
}

func (c *providerServiceClient) CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Provider, error) {
	out := new(Provider)
	err := c.cc.Invoke(ctx, "/admin.v1.ProviderService/CreateProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) GetProviders(ctx context.Context, in *ProviderFilter, opts ...grpc.CallOption) (*ProviderList, error) {
	out := new(ProviderList)
	err := c.cc.Invoke(ctx, "/admin.v1.ProviderService/GetProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProviderServiceServer is the server API for ProviderService service.
type ProviderServiceServer interface {
	// CreateProvider creates a provider for the particular merchant
	CreateProvider(context.Context, *Provider) (*Provider, error)
	// GetProviders returns all providers that the user has access to
	GetProviders(context.Context, *ProviderFilter) (*ProviderList, error)
}

// UnimplementedProviderServiceServer can be embedded to have forward compatible implementations.
type UnimplementedProviderServiceServer struct {
}

func (*UnimplementedProviderServiceServer) CreateProvider(ctx context.Context, req *Provider) (*Provider, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProvider not implemented")
}
func (*UnimplementedProviderServiceServer) GetProviders(ctx context.Context, req *ProviderFilter) (*ProviderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProviders not implemented")
}

func RegisterProviderServiceServer(s *grpc.Server, srv ProviderServiceServer) {
	s.RegisterService(&_ProviderService_serviceDesc, srv)
}

func _ProviderService_CreateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Provider)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).CreateProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProviderService/CreateProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).CreateProvider(ctx, req.(*Provider))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_GetProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProviderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).GetProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.ProviderService/GetProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).GetProviders(ctx, req.(*ProviderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProviderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.ProviderService",
	HandlerType: (*ProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProvider",
			Handler:    _ProviderService_CreateProvider_Handler,
		},
		{
			MethodName: "GetProviders",
			Handler:    _ProviderService_GetProviders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

// CustomerServiceClient is the client API for CustomerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomerServiceClient interface {
	// CreateCustomer creates a customer for the particular merchant
	CreateCustomer(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error)
	// GetCustomers returns all customers that the user has access to
	GetCustomers(ctx context.Context, in *CustomerFilter, opts ...grpc.CallOption) (*CustomerList, error)
}

type customerServiceClient struct {
	cc *grpc.ClientConn
}

func NewCustomerServiceClient(cc *grpc.ClientConn) CustomerServiceClient {
	return &customerServiceClient{cc}
}

func (c *customerServiceClient) CreateCustomer(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/admin.v1.CustomerService/CreateCustomer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerServiceClient) GetCustomers(ctx context.Context, in *CustomerFilter, opts ...grpc.CallOption) (*CustomerList, error) {
	out := new(CustomerList)
	err := c.cc.Invoke(ctx, "/admin.v1.CustomerService/GetCustomers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerServiceServer is the server API for CustomerService service.
type CustomerServiceServer interface {
	// CreateCustomer creates a customer for the particular merchant
	CreateCustomer(context.Context, *Customer) (*Customer, error)
	// GetCustomers returns all customers that the user has access to
	GetCustomers(context.Context, *CustomerFilter) (*CustomerList, error)
}

// UnimplementedCustomerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedCustomerServiceServer struct {
}

func (*UnimplementedCustomerServiceServer) CreateCustomer(ctx context.Context, req *Customer) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCustomer not implemented")
}
func (*UnimplementedCustomerServiceServer) GetCustomers(ctx context.Context, req *CustomerFilter) (*CustomerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCustomers not implemented")
}

func RegisterCustomerServiceServer(s *grpc.Server, srv CustomerServiceServer) {
	s.RegisterService(&_CustomerService_serviceDesc, srv)
}

func _CustomerService_CreateCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Customer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).CreateCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.CustomerService/CreateCustomer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).CreateCustomer(ctx, req.(*Customer))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerService_GetCustomers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).GetCustomers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.v1.CustomerService/GetCustomers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).GetCustomers(ctx, req.(*CustomerFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.v1.CustomerService",
	HandlerType: (*CustomerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCustomer",
			Handler:    _CustomerService_CreateCustomer_Handler,
		},
		{
			MethodName: "GetCustomers",
			Handler:    _CustomerService_GetCustomers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/admin_api.proto",
}

func (m *Merchant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merchant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merchant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerchantList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerchantList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerchantList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.InvitedById) > 0 {
		i -= len(m.InvitedById)
		copy(dAtA[i:], m.InvitedById)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InvitedById)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListStoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListStoresRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListStoresRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InventoryIds) > 0 {
		for iNdEx := len(m.InventoryIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InventoryIds[iNdEx])
			copy(dAtA[i:], m.InventoryIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryIds[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Store) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Store) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Store) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InventoryIds) > 0 {
		for iNdEx := len(m.InventoryIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InventoryIds[iNdEx])
			copy(dAtA[i:], m.InventoryIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryIds[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.InventoryIds) > 0 {
		for iNdEx := len(m.InventoryIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InventoryIds[iNdEx])
			copy(dAtA[i:], m.InventoryIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryIds[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ItemCounter != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.ItemCounter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.ProductCounter != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.ProductCounter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListInventoryItemsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInventoryItemsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListInventoryItemsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddInventoryItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddInventoryItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddInventoryItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateInventoryItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateInventoryItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateInventoryItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InventoryItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Count != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x58
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InventoryItemList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryItemList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryItemList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListProductsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListProductsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListProductsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		for iNdEx := len(m.Filter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProductSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedBy != nil {
		{
			size, err := m.CreatedBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductSchemaId) > 0 {
		i -= len(m.ProductSchemaId)
		copy(dAtA[i:], m.ProductSchemaId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductSchemaId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProductRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProductRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProductRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProductRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Images[iNdEx])
			copy(dAtA[i:], m.Images[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Images[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.DefaultAmount != nil {
		{
			size, err := m.DefaultAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StoreIds) > 0 {
		for iNdEx := len(m.StoreIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StoreIds[iNdEx])
			copy(dAtA[i:], m.StoreIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreIds[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateProductRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateProductRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Images[iNdEx])
			copy(dAtA[i:], m.Images[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Images[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.DefaultAmount != nil {
		{
			size, err := m.DefaultAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StoreIds) > 0 {
		for iNdEx := len(m.StoreIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StoreIds[iNdEx])
			copy(dAtA[i:], m.StoreIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreIds[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Images[iNdEx])
			copy(dAtA[i:], m.Images[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Images[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.DefaultAmount != nil {
		{
			size, err := m.DefaultAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StoreIds) > 0 {
		for iNdEx := len(m.StoreIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StoreIds[iNdEx])
			copy(dAtA[i:], m.StoreIds[iNdEx])
			i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreIds[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProductSchemaId) > 0 {
		i -= len(m.ProductSchemaId)
		copy(dAtA[i:], m.ProductSchemaId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductSchemaId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAdminApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAdminApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Warehouse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Warehouse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Warehouse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WarehouseFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarehouseFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WarehouseFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WarehouseList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WarehouseList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WarehouseList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalAmount != nil {
		{
			size, err := m.TotalAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintAdminApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdminApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdminApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Status) > 0 {
		dAtA16 := make([]byte, len(m.Status)*10)
		var j15 int
		for _, num := range m.Status {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintAdminApi(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Provider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Provider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Provider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *ProviderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Customer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomerId) > 0 {
		i -= len(m.CustomerId)
		copy(dAtA[i:], m.CustomerId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.CustomerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomerFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomerFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintAdminApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *CustomerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomerList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintAdminApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdminApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Merchant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *MerchantList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InvitedById)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 2 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *UserList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ListStoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *GetStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CreateStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *UpdateStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.InventoryIds) > 0 {
		for _, s := range m.InventoryIds {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *Store) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.InventoryIds) > 0 {
		for _, s := range m.InventoryIds {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *StoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.ProductCounter != 0 {
		n += 2 + sovAdminApi(uint64(m.ProductCounter))
	}
	if m.ItemCounter != 0 {
		n += 2 + sovAdminApi(uint64(m.ItemCounter))
	}
	if len(m.InventoryIds) > 0 {
		for _, s := range m.InventoryIds {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *StoreList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ListInventoryItemsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *AddInventoryItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 2 + l + sovAdminApi(uint64(l))
	}
	if m.Count != 0 {
		n += 2 + sovAdminApi(uint64(m.Count))
	}
	return n
}

func (m *UpdateInventoryItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 2 + l + sovAdminApi(uint64(l))
	}
	if m.Count != 0 {
		n += 2 + sovAdminApi(uint64(m.Count))
	}
	return n
}

func (m *InventoryItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovAdminApi(uint64(m.Count))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 2 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *InventoryItemList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ListProductsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Filter) > 0 {
		for _, e := range m.Filter {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ProductList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *ProductSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductSchemaId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedBy != nil {
		l = m.CreatedBy.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetProductRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CreateProductRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.StoreIds) > 0 {
		for _, s := range m.StoreIds {
			l = len(s)
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.DefaultAmount != nil {
		l = m.DefaultAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UpdateProductRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.StoreIds) > 0 {
		for _, s := range m.StoreIds {
			l = len(s)
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.DefaultAmount != nil {
		l = m.DefaultAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.ProductSchemaId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.StoreIds) > 0 {
		for _, s := range m.StoreIds {
			l = len(s)
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.DefaultAmount != nil {
		l = m.DefaultAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 2 + l + sovAdminApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UploadMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdminApi(uint64(len(k))) + 1 + len(v) + sovAdminApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdminApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Warehouse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WarehouseFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WarehouseList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAdminApi(uint64(m.Status))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	if m.TotalAmount != nil {
		l = m.TotalAmount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovAdminApi(uint64(m.CreatedAt))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *OrderItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovAdminApi(uint64(m.Count))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *OrderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdminApi(uint64(l))
		}
	}
	return n
}

func (m *OrderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovAdminApi(uint64(e))
		}
		n += 1 + sovAdminApi(uint64(l)) + l
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *Provider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *ProviderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *ProviderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Customer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CustomerFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovAdminApi(uint64(l))
	}
	return n
}

func (m *CustomerList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovAdminApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdminApi(x uint64) (n int) {
	return sovAdminApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Merchant) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Merchant{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MerchantList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Merchant{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Merchant", "Merchant", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&MerchantList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *User) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&User{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`InvitedById:` + fmt.Sprintf("%v", this.InvitedById) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Thumbnail:` + fmt.Sprintf("%v", this.Thumbnail) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*User{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "User", "User", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&UserList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListStoresRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListStoresRequest{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetStoreRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetStoreRequest{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateStoreRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateStoreRequest{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateStoreRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateStoreRequest{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`InventoryIds:` + fmt.Sprintf("%v", this.InventoryIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Store) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Store{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`InventoryIds:` + fmt.Sprintf("%v", this.InventoryIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreDetails) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*InventoryItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "InventoryItem", "InventoryItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&StoreDetails{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`ProductCounter:` + fmt.Sprintf("%v", this.ProductCounter) + `,`,
		`ItemCounter:` + fmt.Sprintf("%v", this.ItemCounter) + `,`,
		`InventoryIds:` + fmt.Sprintf("%v", this.InventoryIds) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Store{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Store", "Store", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&StoreList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListInventoryItemsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListInventoryItemsRequest{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`InventoryId:` + fmt.Sprintf("%v", this.InventoryId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddInventoryItemRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddInventoryItemRequest{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`InventoryId:` + fmt.Sprintf("%v", this.InventoryId) + `,`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateInventoryItemRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateInventoryItemRequest{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`InventoryId:` + fmt.Sprintf("%v", this.InventoryId) + `,`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InventoryItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InventoryItem{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`InventoryId:` + fmt.Sprintf("%v", this.InventoryId) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InventoryItemList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*InventoryItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "InventoryItem", "InventoryItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&InventoryItemList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListProductsRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFilter := "[]*Expression{"
	for _, f := range this.Filter {
		repeatedStringForFilter += strings.Replace(fmt.Sprintf("%v", f), "Expression", "v1.Expression", 1) + ","
	}
	repeatedStringForFilter += "}"
	s := strings.Join([]string{`&ListProductsRequest{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Filter:` + repeatedStringForFilter + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Product{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Product", "Product", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ProductList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductSchema) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&ProductSchema{`,
		`ProductSchemaId:` + fmt.Sprintf("%v", this.ProductSchemaId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`CreatedBy:` + strings.Replace(this.CreatedBy.String(), "User", "User", 1) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetProductRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetProductRequest{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateProductRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&CreateProductRequest{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreIds:` + fmt.Sprintf("%v", this.StoreIds) + `,`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultAmount:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAmount), "Amount", "v1.Amount", 1) + `,`,
		`Images:` + fmt.Sprintf("%v", this.Images) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateProductRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&UpdateProductRequest{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreIds:` + fmt.Sprintf("%v", this.StoreIds) + `,`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultAmount:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAmount), "Amount", "v1.Amount", 1) + `,`,
		`Images:` + fmt.Sprintf("%v", this.Images) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&Product{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`ProductSchemaId:` + fmt.Sprintf("%v", this.ProductSchemaId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreIds:` + fmt.Sprintf("%v", this.StoreIds) + `,`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`DefaultAmount:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAmount), "Amount", "v1.Amount", 1) + `,`,
		`Images:` + fmt.Sprintf("%v", this.Images) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadMeta) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&UploadMeta{`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`Link:` + fmt.Sprintf("%v", this.Link) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *Warehouse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Warehouse{`,
		`}`,
	}, "")
	return s
}
func (this *WarehouseFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WarehouseFilter{`,
		`}`,
	}, "")
	return s
}
func (this *WarehouseList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Warehouse{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Warehouse", "Warehouse", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&WarehouseList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*OrderItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "OrderItem", "OrderItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&Order{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Note:` + fmt.Sprintf("%v", this.Note) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`TotalAmount:` + strings.Replace(fmt.Sprintf("%v", this.TotalAmount), "Amount", "v1.Amount", 1) + `,`,
		`CreatedAt:` + fmt.Sprintf("%v", this.CreatedAt) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderItem{`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Order{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Order", "Order", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&OrderList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderFilter{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Provider) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Provider{`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProviderFilter{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProviderList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProviderList{`,
		`}`,
	}, "")
	return s
}
func (this *Customer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Customer{`,
		`CustomerId:` + fmt.Sprintf("%v", this.CustomerId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomerFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomerFilter{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomerList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomerList{`,
		`}`,
	}, "")
	return s
}
func valueToStringAdminApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Merchant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merchant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merchant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerchantList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerchantList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerchantList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Merchant{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvitedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &User{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListStoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListStoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListStoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryIds = append(m.InventoryIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryIds = append(m.InventoryIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductCounter", wireType)
			}
			m.ProductCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemCounter", wireType)
			}
			m.ItemCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryIds = append(m.InventoryIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &InventoryItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Store{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInventoryItemsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInventoryItemsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInventoryItemsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddInventoryItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddInventoryItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddInventoryItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateInventoryItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateInventoryItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateInventoryItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryItemList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryItemList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryItemList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &InventoryItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListProductsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListProductsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListProductsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, &v1.Expression{})
			if err := m.Filter[len(m.Filter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Product{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSchemaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSchemaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedBy == nil {
				m.CreatedBy = &User{}
			}
			if err := m.CreatedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreIds = append(m.StoreIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultAmount == nil {
				m.DefaultAmount = &v1.Amount{}
			}
			if err := m.DefaultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreIds = append(m.StoreIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultAmount == nil {
				m.DefaultAmount = &v1.Amount{}
			}
			if err := m.DefaultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSchemaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSchemaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreIds = append(m.StoreIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultAmount == nil {
				m.DefaultAmount = &v1.Amount{}
			}
			if err := m.DefaultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdminApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdminApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdminApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Warehouse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Warehouse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Warehouse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarehouseFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarehouseFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarehouseFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WarehouseList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WarehouseList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WarehouseList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Warehouse{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &OrderItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalAmount == nil {
				m.TotalAmount = &v1.Amount{}
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Order{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v OrderStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= OrderStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdminApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdminApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdminApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]OrderStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v OrderStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdminApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= OrderStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Provider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdminApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdminApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdminApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdminApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdminApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdminApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdminApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdminApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdminApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdminApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdminApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdminApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdminApi = fmt.Errorf("proto: unexpected end of group")
)
