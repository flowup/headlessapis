// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/client_api.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/flowup/headlessapis/go-sdk/common/v1"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EmailPassword struct {
	Email      string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Password   string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	MerchantId string `protobuf:"bytes,3,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *EmailPassword) Reset()      { *m = EmailPassword{} }
func (*EmailPassword) ProtoMessage() {}
func (*EmailPassword) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{0}
}
func (m *EmailPassword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmailPassword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmailPassword.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmailPassword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmailPassword.Merge(m, src)
}
func (m *EmailPassword) XXX_Size() int {
	return m.Size()
}
func (m *EmailPassword) XXX_DiscardUnknown() {
	xxx_messageInfo_EmailPassword.DiscardUnknown(m)
}

var xxx_messageInfo_EmailPassword proto.InternalMessageInfo

func (m *EmailPassword) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *EmailPassword) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *EmailPassword) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type Customer struct {
	CustomerId string `protobuf:"bytes,1,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Thumbnail  string `protobuf:"bytes,3,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *Customer) Reset()      { *m = Customer{} }
func (*Customer) ProtoMessage() {}
func (*Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{1}
}
func (m *Customer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Customer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Customer.Merge(m, src)
}
func (m *Customer) XXX_Size() int {
	return m.Size()
}
func (m *Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Customer proto.InternalMessageInfo

func (m *Customer) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *Customer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Customer) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

type Store struct {
	StoreId    string `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	Name       string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	//    string location = 11;
	Address     string `protobuf:"bytes,12,opt,name=address,proto3" json:"address,omitempty"`
	Description string `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *Store) Reset()      { *m = Store{} }
func (*Store) ProtoMessage() {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{2}
}
func (m *Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return m.Size()
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *Store) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Store) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Store) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Store) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Request for loading a single store by ID from a given merchant.
type GetStoreRequest struct {
	StoreId    string `protobuf:"bytes,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
}

func (m *GetStoreRequest) Reset()      { *m = GetStoreRequest{} }
func (*GetStoreRequest) ProtoMessage() {}
func (*GetStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{3}
}
func (m *GetStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreRequest.Merge(m, src)
}
func (m *GetStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreRequest proto.InternalMessageInfo

func (m *GetStoreRequest) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *GetStoreRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

type StoreItem struct {
	MerchantId  string           `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreItemId string           `protobuf:"bytes,2,opt,name=store_item_id,json=storeItemId,proto3" json:"store_item_id,omitempty"`
	InventoryId string           `protobuf:"bytes,3,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id,omitempty"`
	CreatedAt   *types.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Amount      *v1.Amount       `protobuf:"bytes,10,opt,name=amount,proto3" json:"amount,omitempty"`
	Count       uint32           `protobuf:"varint,11,opt,name=count,proto3" json:"count,omitempty"`
	Product     *Product         `protobuf:"bytes,50,opt,name=product,proto3" json:"product,omitempty"`
}

func (m *StoreItem) Reset()      { *m = StoreItem{} }
func (*StoreItem) ProtoMessage() {}
func (*StoreItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{4}
}
func (m *StoreItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreItem.Merge(m, src)
}
func (m *StoreItem) XXX_Size() int {
	return m.Size()
}
func (m *StoreItem) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreItem.DiscardUnknown(m)
}

var xxx_messageInfo_StoreItem proto.InternalMessageInfo

func (m *StoreItem) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *StoreItem) GetStoreItemId() string {
	if m != nil {
		return m.StoreItemId
	}
	return ""
}

func (m *StoreItem) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

func (m *StoreItem) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *StoreItem) GetAmount() *v1.Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *StoreItem) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *StoreItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

type Product struct {
	ProductId   string            `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	MerchantId  string            `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreId     string            `protobuf:"bytes,3,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	Name        string            `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	Description string            `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	Images      []string          `protobuf:"bytes,12,rep,name=images,proto3" json:"images,omitempty"`
	Labels      map[string]string `protobuf:"bytes,100,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes  map[string]string `protobuf:"bytes,101,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{5}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Product) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *Product) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *Product) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Product) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Request for loading a product directly by its ID
type GetProductRequest struct {
	ProductId  string `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	MerchantId string `protobuf:"bytes,2,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreId    string `protobuf:"bytes,3,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
}

func (m *GetProductRequest) Reset()      { *m = GetProductRequest{} }
func (*GetProductRequest) ProtoMessage() {}
func (*GetProductRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{6}
}
func (m *GetProductRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProductRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProductRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetProductRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProductRequest.Merge(m, src)
}
func (m *GetProductRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetProductRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProductRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetProductRequest proto.InternalMessageInfo

func (m *GetProductRequest) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *GetProductRequest) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *GetProductRequest) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

// Request for filtering product in a store
type ProductFilter struct {
	MerchantId string `protobuf:"bytes,1,opt,name=merchant_id,json=merchantId,proto3" json:"merchant_id,omitempty"`
	StoreId    string `protobuf:"bytes,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	// Possible attributes on which expressions can be built on:
	// - "product.createdAt"
	// - "product.name"
	// - "product.description"
	// - "product.labels"
	// - "product.attributes"
	// - "amount"
	// - "amount.value"
	// - "amount.currency"
	// - "count"
	Filter map[string]*v1.ExpressionList `protobuf:"bytes,10,rep,name=filter,proto3" json:"filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProductFilter) Reset()      { *m = ProductFilter{} }
func (*ProductFilter) ProtoMessage() {}
func (*ProductFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{7}
}
func (m *ProductFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductFilter.Merge(m, src)
}
func (m *ProductFilter) XXX_Size() int {
	return m.Size()
}
func (m *ProductFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ProductFilter proto.InternalMessageInfo

func (m *ProductFilter) GetMerchantId() string {
	if m != nil {
		return m.MerchantId
	}
	return ""
}

func (m *ProductFilter) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *ProductFilter) GetFilter() map[string]*v1.ExpressionList {
	if m != nil {
		return m.Filter
	}
	return nil
}

type StoreItemList struct {
	Items []*StoreItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *StoreItemList) Reset()      { *m = StoreItemList{} }
func (*StoreItemList) ProtoMessage() {}
func (*StoreItemList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{8}
}
func (m *StoreItemList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreItemList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreItemList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreItemList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreItemList.Merge(m, src)
}
func (m *StoreItemList) XXX_Size() int {
	return m.Size()
}
func (m *StoreItemList) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreItemList.DiscardUnknown(m)
}

var xxx_messageInfo_StoreItemList proto.InternalMessageInfo

func (m *StoreItemList) GetItems() []*StoreItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type Order struct {
	OrderId string       `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Items   []*OrderItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	Status  string       `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{9}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetItems() []*OrderItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Order) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type OrderItem struct {
	Product *Product `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	Count   int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	OrderId string   `protobuf:"bytes,10,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *OrderItem) Reset()      { *m = OrderItem{} }
func (*OrderItem) ProtoMessage() {}
func (*OrderItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{10}
}
func (m *OrderItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderItem.Merge(m, src)
}
func (m *OrderItem) XXX_Size() int {
	return m.Size()
}
func (m *OrderItem) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderItem.DiscardUnknown(m)
}

var xxx_messageInfo_OrderItem proto.InternalMessageInfo

func (m *OrderItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OrderItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *OrderItem) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type OrderList struct {
	Items []*Order `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *OrderList) Reset()      { *m = OrderList{} }
func (*OrderList) ProtoMessage() {}
func (*OrderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{11}
}
func (m *OrderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderList.Merge(m, src)
}
func (m *OrderList) XXX_Size() int {
	return m.Size()
}
func (m *OrderList) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderList.DiscardUnknown(m)
}

var xxx_messageInfo_OrderList proto.InternalMessageInfo

func (m *OrderList) GetItems() []*Order {
	if m != nil {
		return m.Items
	}
	return nil
}

type OrderFilter struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *OrderFilter) Reset()      { *m = OrderFilter{} }
func (*OrderFilter) ProtoMessage() {}
func (*OrderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{12}
}
func (m *OrderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilter.Merge(m, src)
}
func (m *OrderFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilter proto.InternalMessageInfo

func (m *OrderFilter) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func init() {
	proto.RegisterType((*EmailPassword)(nil), "client.v1.EmailPassword")
	proto.RegisterType((*Customer)(nil), "client.v1.Customer")
	proto.RegisterType((*Store)(nil), "client.v1.Store")
	proto.RegisterType((*GetStoreRequest)(nil), "client.v1.GetStoreRequest")
	proto.RegisterType((*StoreItem)(nil), "client.v1.StoreItem")
	proto.RegisterType((*Product)(nil), "client.v1.Product")
	proto.RegisterMapType((map[string]string)(nil), "client.v1.Product.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "client.v1.Product.LabelsEntry")
	proto.RegisterType((*GetProductRequest)(nil), "client.v1.GetProductRequest")
	proto.RegisterType((*ProductFilter)(nil), "client.v1.ProductFilter")
	proto.RegisterMapType((map[string]*v1.ExpressionList)(nil), "client.v1.ProductFilter.FilterEntry")
	proto.RegisterType((*StoreItemList)(nil), "client.v1.StoreItemList")
	proto.RegisterType((*Order)(nil), "client.v1.Order")
	proto.RegisterType((*OrderItem)(nil), "client.v1.OrderItem")
	proto.RegisterType((*OrderList)(nil), "client.v1.OrderList")
	proto.RegisterType((*OrderFilter)(nil), "client.v1.OrderFilter")
}

func init() { proto.RegisterFile("v1/client_api.proto", fileDescriptor_7b71fc9c9ecb49eb) }

var fileDescriptor_7b71fc9c9ecb49eb = []byte{
	// 1241 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xf7, 0xda, 0x8d, 0x63, 0xbf, 0xb5, 0x9b, 0x74, 0x9a, 0x6f, 0xb4, 0xdd, 0x6f, 0xba, 0x09,
	0x2b, 0x40, 0x26, 0x02, 0x6f, 0xe3, 0x4a, 0xa8, 0x35, 0x54, 0xc8, 0x85, 0x34, 0x72, 0x55, 0x44,
	0x71, 0x52, 0x21, 0x21, 0xa1, 0x68, 0xec, 0x9d, 0xd8, 0xdb, 0x7a, 0x7f, 0xb0, 0x33, 0xeb, 0x12,
	0x42, 0x24, 0xc4, 0x85, 0x2b, 0x12, 0x27, 0x0e, 0x70, 0xee, 0x3f, 0xc1, 0x9d, 0x1b, 0x91, 0xb8,
	0xf4, 0x06, 0x71, 0x38, 0x70, 0xec, 0x9f, 0x80, 0x66, 0x76, 0xd6, 0x5e, 0xff, 0x28, 0x34, 0x02,
	0x4e, 0xd9, 0x79, 0xef, 0xcd, 0xe7, 0xf3, 0xe6, 0xbd, 0xcf, 0x9b, 0x89, 0xe1, 0xf2, 0x60, 0xcb,
	0xea, 0xf4, 0x1d, 0xe2, 0xb1, 0x7d, 0x1c, 0x38, 0xd5, 0x20, 0xf4, 0x99, 0x8f, 0x8a, 0xb1, 0xa5,
	0x3a, 0xd8, 0xd2, 0xd7, 0xba, 0xbe, 0xdf, 0xed, 0x13, 0x0b, 0x07, 0x8e, 0x85, 0x3d, 0xcf, 0x67,
	0x98, 0x39, 0xbe, 0x47, 0xe3, 0x40, 0xfd, 0xff, 0xd2, 0x2b, 0x56, 0xed, 0xe8, 0xc0, 0x22, 0x6e,
	0xc0, 0x0e, 0xa5, 0x73, 0x7d, 0xda, 0xc9, 0x1c, 0x97, 0x50, 0x86, 0xdd, 0x40, 0x06, 0x2c, 0x71,
	0x6e, 0xdf, 0x75, 0x7d, 0x2f, 0x36, 0x98, 0x6d, 0x28, 0x6f, 0xbb, 0xd8, 0xe9, 0xdf, 0xc7, 0x94,
	0x3e, 0xf6, 0x43, 0x1b, 0xad, 0xc0, 0x02, 0xe1, 0x06, 0x4d, 0xd9, 0x50, 0x2a, 0xc5, 0x56, 0xbc,
	0x40, 0x3a, 0x14, 0x02, 0x19, 0xa1, 0x65, 0x85, 0x63, 0xb4, 0x46, 0xeb, 0xa0, 0xba, 0x24, 0xec,
	0xf4, 0xb0, 0xc7, 0xf6, 0x1d, 0x5b, 0xcb, 0x09, 0x37, 0x24, 0xa6, 0xa6, 0x6d, 0x7e, 0x02, 0x85,
	0x77, 0x23, 0xca, 0x7c, 0x97, 0x84, 0x3c, 0xb8, 0x23, 0xbf, 0x79, 0x70, 0x4c, 0x02, 0x89, 0xa9,
	0x69, 0x23, 0x04, 0x17, 0x3c, 0xec, 0x12, 0xc9, 0x22, 0xbe, 0xd1, 0x1a, 0x14, 0x59, 0x2f, 0x72,
	0xdb, 0x1e, 0xcf, 0x2b, 0xc6, 0x1f, 0x1b, 0xcc, 0xef, 0x14, 0x58, 0xd8, 0x65, 0x7e, 0x48, 0xd0,
	0x15, 0x28, 0x50, 0xfe, 0x31, 0x46, 0x5e, 0x14, 0xeb, 0xe6, 0x4c, 0x92, 0xd9, 0xe9, 0x24, 0x47,
	0xbc, 0x90, 0xe2, 0xd5, 0x60, 0x11, 0xdb, 0x76, 0x48, 0x28, 0xd5, 0x4a, 0x31, 0x9c, 0x5c, 0xa2,
	0x0d, 0x50, 0x6d, 0x42, 0x3b, 0xa1, 0x13, 0xf0, 0xde, 0x68, 0x65, 0xe1, 0x4d, 0x9b, 0xee, 0x5e,
	0x28, 0xa8, 0xcb, 0x25, 0xf3, 0x7d, 0x58, 0xda, 0x21, 0x4c, 0x64, 0xd7, 0x22, 0x9f, 0x46, 0x84,
	0xb2, 0x7f, 0x92, 0xa4, 0xf9, 0x7d, 0x16, 0x8a, 0x02, 0xac, 0xc9, 0x88, 0x3b, 0x1d, 0xae, 0xcc,
	0x9c, 0xc9, 0x84, 0xb2, 0xa4, 0x62, 0xc4, 0x1d, 0x23, 0xaa, 0x34, 0x81, 0x68, 0xda, 0xe8, 0x25,
	0x28, 0x39, 0xde, 0x80, 0x78, 0xcc, 0x0f, 0x0f, 0xc7, 0xed, 0x53, 0x47, 0xb6, 0xa6, 0x8d, 0x6e,
	0x02, 0x74, 0x42, 0x82, 0x19, 0xb1, 0xf7, 0x31, 0xd3, 0x2e, 0x6c, 0x28, 0x15, 0xb5, 0xa6, 0x57,
	0x63, 0xa9, 0x55, 0x13, 0xa9, 0x55, 0xf7, 0x12, 0xa9, 0xb5, 0x8a, 0x32, 0xba, 0xc1, 0xd0, 0x6b,
	0x90, 0xc7, 0xae, 0x1f, 0x79, 0x4c, 0xd4, 0x55, 0xad, 0x5d, 0xaa, 0x4a, 0xf5, 0x0d, 0xb6, 0xaa,
	0x0d, 0xe1, 0x68, 0xc9, 0x00, 0x2e, 0xbc, 0x8e, 0x88, 0x54, 0x37, 0x94, 0x4a, 0xb9, 0x15, 0x2f,
	0xd0, 0xeb, 0xb0, 0x18, 0x84, 0xbe, 0x1d, 0x75, 0x98, 0x56, 0x13, 0x08, 0xa8, 0x3a, 0x9a, 0x94,
	0xea, 0xfd, 0xd8, 0xd3, 0x4a, 0x42, 0xcc, 0x27, 0x39, 0x58, 0x94, 0x46, 0x74, 0x15, 0x40, 0x9a,
	0xc7, 0xc5, 0x29, 0x4a, 0xcb, 0x8b, 0x08, 0x22, 0xdd, 0xa7, 0xdc, 0x64, 0x9f, 0xe6, 0x69, 0x65,
	0x4a, 0x11, 0xea, 0x8c, 0x22, 0xd0, 0x2a, 0xe4, 0x1d, 0x17, 0x77, 0x09, 0x17, 0x53, 0xae, 0x52,
	0x6c, 0xc9, 0x15, 0x7a, 0x13, 0xf2, 0x7d, 0xdc, 0x26, 0x7d, 0xaa, 0xd9, 0x1b, 0xb9, 0x8a, 0x5a,
	0x33, 0x66, 0x4f, 0x58, 0xbd, 0x27, 0x02, 0xb6, 0x3d, 0x16, 0x1e, 0xb6, 0x64, 0x34, 0xba, 0x0d,
	0x80, 0x19, 0x0b, 0x9d, 0x76, 0xc4, 0x08, 0xd5, 0x88, 0xd8, 0x6b, 0xce, 0xd9, 0xdb, 0x18, 0x05,
	0xc5, 0xfb, 0x53, 0xbb, 0xf4, 0x9b, 0xa0, 0xa6, 0xa0, 0xd1, 0x32, 0xe4, 0x1e, 0x91, 0x43, 0x59,
	0x2c, 0xfe, 0xc9, 0xbb, 0x32, 0xc0, 0xfd, 0x28, 0x99, 0xc7, 0x78, 0x51, 0xcf, 0xde, 0x50, 0xf4,
	0x5b, 0xb0, 0x34, 0x85, 0x7c, 0x9e, 0xed, 0xa6, 0x07, 0x97, 0x76, 0x08, 0x4b, 0x3a, 0x28, 0x67,
	0xe3, 0xbf, 0xeb, 0x99, 0xf9, 0xab, 0x02, 0x65, 0xc9, 0x76, 0xc7, 0xe9, 0xb3, 0xf8, 0x2a, 0xfa,
	0xeb, 0xf1, 0x49, 0xa3, 0x65, 0x27, 0x15, 0xf0, 0x36, 0xe4, 0x0f, 0x04, 0x8a, 0x06, 0xa2, 0xee,
	0x2f, 0xcf, 0xd6, 0x3d, 0x66, 0xa9, 0xc6, 0x7f, 0x64, 0xe7, 0xe2, 0x3d, 0xfa, 0x1e, 0xa8, 0x29,
	0xf3, 0x9c, 0xb2, 0x59, 0xe9, 0xb2, 0xa9, 0xb5, 0x2b, 0xa9, 0xa9, 0xd9, 0xfe, 0x2c, 0xe0, 0x37,
	0x90, 0xe3, 0x7b, 0xf7, 0x1c, 0xca, 0xd2, 0x15, 0x7d, 0x0b, 0xca, 0xa3, 0xbb, 0x81, 0xfb, 0xd0,
	0x26, 0x2c, 0xf0, 0xc1, 0xa7, 0x9a, 0x22, 0x72, 0x5c, 0x49, 0xe5, 0x38, 0x0a, 0x6c, 0xc5, 0x21,
	0xe6, 0x01, 0x2c, 0x7c, 0x10, 0xda, 0x24, 0xe4, 0x87, 0xf6, 0xf9, 0x47, 0xea, 0x7a, 0x12, 0xeb,
	0xa6, 0x3d, 0xc6, 0xcb, 0xce, 0xe0, 0x89, 0xbd, 0x29, 0x3c, 0x2e, 0x76, 0xca, 0x30, 0x8b, 0xa8,
	0xec, 0x83, 0x5c, 0x99, 0x0f, 0xa1, 0x38, 0x8a, 0x4d, 0x0f, 0xb7, 0xf2, 0xb7, 0xc3, 0x3d, 0xbe,
	0x20, 0x78, 0x51, 0x16, 0x92, 0x0b, 0x22, 0x9d, 0x2f, 0x4c, 0xe4, 0x6b, 0x5e, 0x97, 0x5c, 0xa2,
	0x18, 0xaf, 0x4e, 0x16, 0x63, 0x79, 0x3a, 0xf9, 0xa4, 0x10, 0x15, 0x50, 0xc5, 0x5a, 0x8a, 0xe4,
	0xf9, 0xe5, 0xa8, 0xfd, 0xac, 0x80, 0xda, 0x88, 0x58, 0x6f, 0x97, 0x84, 0x03, 0xa7, 0x43, 0xd0,
	0x3e, 0xa0, 0x5d, 0xa7, 0xeb, 0x35, 0xbd, 0x8f, 0x1c, 0xd6, 0x1b, 0xbd, 0xa7, 0x5a, 0x8a, 0x68,
	0xe2, 0xa5, 0xd5, 0x2f, 0xa7, 0x3c, 0xc9, 0xfb, 0x68, 0xea, 0x5f, 0xfd, 0xf2, 0xfb, 0xb7, 0xd9,
	0x15, 0x73, 0xc9, 0xc2, 0x1d, 0x71, 0xc0, 0x3a, 0x15, 0x98, 0x75, 0x65, 0x33, 0x21, 0x78, 0x10,
	0xfc, 0xfb, 0x04, 0x0f, 0x82, 0xba, 0xb2, 0x59, 0xfb, 0x1c, 0x4a, 0x42, 0x18, 0xc9, 0x89, 0x1e,
	0x42, 0x21, 0x79, 0xbd, 0x90, 0x9e, 0x02, 0x9b, 0x7a, 0xd2, 0xf4, 0xe5, 0x69, 0x65, 0x99, 0xd7,
	0x04, 0xcb, 0x26, 0xaa, 0x58, 0xc9, 0x3c, 0x59, 0x47, 0xa9, 0x61, 0x3b, 0xb6, 0xc4, 0x20, 0x59,
	0x47, 0xc9, 0x7c, 0x1d, 0xd7, 0x7e, 0xc8, 0xc2, 0x4a, 0x73, 0xf4, 0xe8, 0x30, 0xe2, 0x26, 0x49,
	0x7c, 0x01, 0x25, 0xde, 0x40, 0x29, 0x07, 0x3a, 0x71, 0xde, 0x89, 0x51, 0xd3, 0xb5, 0x79, 0x02,
	0xe7, 0x7b, 0xcd, 0x1b, 0x22, 0x9d, 0x1a, 0xba, 0xf6, 0xa2, 0xe9, 0x58, 0x89, 0xe8, 0xbe, 0x56,
	0x00, 0xc6, 0xf7, 0x14, 0x5a, 0x9b, 0xac, 0xc2, 0xe4, 0xf5, 0xa5, 0xcf, 0x9d, 0x30, 0x73, 0x5b,
	0x90, 0xbf, 0x83, 0x6e, 0x9d, 0x97, 0xdc, 0x3a, 0x1a, 0x5f, 0x86, 0xc7, 0xb5, 0x1f, 0x73, 0x50,
	0x12, 0xca, 0x4c, 0x0a, 0xf3, 0x21, 0x5c, 0xdc, 0x21, 0xac, 0xd1, 0x61, 0xce, 0x80, 0xc4, 0xb3,
	0xbb, 0x3a, 0xf3, 0x28, 0x6f, 0xf3, 0x7f, 0x0e, 0xf5, 0x19, 0xb1, 0x9b, 0xff, 0x13, 0x39, 0x2d,
	0xa1, 0xb2, 0x25, 0xd4, 0x5c, 0xc7, 0x02, 0x05, 0xed, 0xc3, 0xc5, 0x86, 0x6d, 0xf3, 0xac, 0xf7,
	0xfc, 0x18, 0x72, 0xee, 0x90, 0xcf, 0x01, 0x7c, 0x45, 0x00, 0xae, 0x9b, 0x7a, 0x0c, 0x68, 0x1d,
	0x25, 0x53, 0x73, 0x6c, 0xf1, 0xb9, 0xaa, 0x63, 0xdb, 0xe6, 0x12, 0xee, 0xc2, 0xe5, 0x16, 0x71,
	0xfd, 0x81, 0xa8, 0xcc, 0x9d, 0xd0, 0x77, 0xcf, 0xc7, 0x52, 0x11, 0x2c, 0xa6, 0x79, 0xf5, 0x39,
	0x2c, 0xa1, 0xc0, 0xe6, 0x44, 0xef, 0x81, 0xba, 0x1b, 0xb5, 0x5d, 0x87, 0xc5, 0x04, 0x33, 0x50,
	0x73, 0xc0, 0x2f, 0x09, 0x70, 0xd5, 0xcc, 0xcb, 0x9a, 0x28, 0x9b, 0xe8, 0x2e, 0x00, 0xd7, 0x8f,
	0xf0, 0x53, 0xb4, 0x3a, 0xbd, 0x45, 0xea, 0x6e, 0x26, 0x7b, 0xa1, 0xb9, 0x8b, 0x02, 0xae, 0x80,
	0x24, 0xdc, 0x6d, 0x72, 0x72, 0x6a, 0x64, 0x9e, 0x9e, 0x1a, 0x99, 0x67, 0xa7, 0x86, 0xf2, 0xe5,
	0xd0, 0x50, 0x9e, 0x0c, 0x0d, 0xe5, 0xa7, 0xa1, 0xa1, 0x9c, 0x0c, 0x0d, 0xe5, 0xb7, 0xa1, 0xa1,
	0xfc, 0x31, 0x34, 0x32, 0xcf, 0x86, 0x86, 0xf2, 0xcd, 0x99, 0x91, 0x39, 0x39, 0x33, 0x32, 0x4f,
	0xcf, 0x8c, 0xcc, 0xc7, 0x56, 0xd7, 0x61, 0xbd, 0xa8, 0xcd, 0x1f, 0x00, 0xeb, 0xa0, 0xef, 0x3f,
	0x8e, 0x02, 0xab, 0x47, 0xb0, 0xdd, 0x27, 0x94, 0xe2, 0xc0, 0xa1, 0x56, 0xd7, 0x7f, 0x83, 0xda,
	0x8f, 0xe4, 0xef, 0x09, 0x6b, 0xb0, 0xd5, 0xce, 0x8b, 0xde, 0x5f, 0xff, 0x33, 0x00, 0x00, 0xff,
	0xff, 0x65, 0xb7, 0x1e, 0x67, 0x66, 0x0c, 0x00, 0x00,
}

func (this *EmailPassword) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmailPassword)
	if !ok {
		that2, ok := that.(EmailPassword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *Customer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Customer)
	if !ok {
		that2, ok := that.(Customer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Thumbnail != that1.Thumbnail {
		return false
	}
	return true
}
func (this *Store) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Store)
	if !ok {
		that2, ok := that.(Store)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *GetStoreRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetStoreRequest)
	if !ok {
		that2, ok := that.(GetStoreRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	return true
}
func (this *StoreItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreItem)
	if !ok {
		that2, ok := that.(StoreItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreItemId != that1.StoreItemId {
		return false
	}
	if this.InventoryId != that1.InventoryId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Images) != len(that1.Images) {
		return false
	}
	for i := range this.Images {
		if this.Images[i] != that1.Images[i] {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *GetProductRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetProductRequest)
	if !ok {
		that2, ok := that.(GetProductRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *ProductFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductFilter)
	if !ok {
		that2, ok := that.(ProductFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MerchantId != that1.MerchantId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if len(this.Filter) != len(that1.Filter) {
		return false
	}
	for i := range this.Filter {
		if !this.Filter[i].Equal(that1.Filter[i]) {
			return false
		}
	}
	return true
}
func (this *StoreItemList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StoreItemList)
	if !ok {
		that2, ok := that.(StoreItemList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *OrderItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderItem)
	if !ok {
		that2, ok := that.(OrderItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *OrderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderList)
	if !ok {
		that2, ok := that.(OrderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *OrderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderFilter)
	if !ok {
		that2, ok := that.(OrderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *EmailPassword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.EmailPassword{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Customer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.Customer{")
	s = append(s, "CustomerId: "+fmt.Sprintf("%#v", this.CustomerId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Store) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1.Store{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetStoreRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.GetStoreRequest{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&v1.StoreItem{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreItemId: "+fmt.Sprintf("%#v", this.StoreItemId)+",\n")
	s = append(s, "InventoryId: "+fmt.Sprintf("%#v", this.InventoryId)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&v1.Product{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Images: "+fmt.Sprintf("%#v", this.Images)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetProductRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.GetProductRequest{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.ProductFilter{")
	s = append(s, "MerchantId: "+fmt.Sprintf("%#v", this.MerchantId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	keysForFilter := make([]string, 0, len(this.Filter))
	for k, _ := range this.Filter {
		keysForFilter = append(keysForFilter, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFilter)
	mapStringForFilter := "map[string]*v1.ExpressionList{"
	for _, k := range keysForFilter {
		mapStringForFilter += fmt.Sprintf("%#v: %#v,", k, this.Filter[k])
	}
	mapStringForFilter += "}"
	if this.Filter != nil {
		s = append(s, "Filter: "+mapStringForFilter+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StoreItemList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.StoreItemList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.Order{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.OrderItem{")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderFilter{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClientApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	SignInWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error)
	SignUpWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) SignInWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/client.v1.AuthService/SignInWithPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SignUpWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/client.v1.AuthService/SignUpWithPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	SignInWithPassword(context.Context, *EmailPassword) (*Customer, error)
	SignUpWithPassword(context.Context, *EmailPassword) (*Customer, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) SignInWithPassword(ctx context.Context, req *EmailPassword) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInWithPassword not implemented")
}
func (*UnimplementedAuthServiceServer) SignUpWithPassword(ctx context.Context, req *EmailPassword) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpWithPassword not implemented")
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_SignInWithPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SignInWithPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.AuthService/SignInWithPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SignInWithPassword(ctx, req.(*EmailPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SignUpWithPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SignUpWithPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.AuthService/SignUpWithPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SignUpWithPassword(ctx, req.(*EmailPassword))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignInWithPassword",
			Handler:    _AuthService_SignInWithPassword_Handler,
		},
		{
			MethodName: "SignUpWithPassword",
			Handler:    _AuthService_SignUpWithPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

// StoreServiceClient is the client API for StoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreServiceClient interface {
	// Retrieves basic information about a given store
	GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*Store, error)
}

type storeServiceClient struct {
	cc *grpc.ClientConn
}

func NewStoreServiceClient(cc *grpc.ClientConn) StoreServiceClient {
	return &storeServiceClient{cc}
}

func (c *storeServiceClient) GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*Store, error) {
	out := new(Store)
	err := c.cc.Invoke(ctx, "/client.v1.StoreService/GetStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoreServiceServer is the server API for StoreService service.
type StoreServiceServer interface {
	// Retrieves basic information about a given store
	GetStore(context.Context, *GetStoreRequest) (*Store, error)
}

// UnimplementedStoreServiceServer can be embedded to have forward compatible implementations.
type UnimplementedStoreServiceServer struct {
}

func (*UnimplementedStoreServiceServer) GetStore(ctx context.Context, req *GetStoreRequest) (*Store, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStore not implemented")
}

func RegisterStoreServiceServer(s *grpc.Server, srv StoreServiceServer) {
	s.RegisterService(&_StoreService_serviceDesc, srv)
}

func _StoreService_GetStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServiceServer).GetStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.StoreService/GetStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServiceServer).GetStore(ctx, req.(*GetStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.StoreService",
	HandlerType: (*StoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStore",
			Handler:    _StoreService_GetStore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

// InventoryItemServiceClient is the client API for InventoryItemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InventoryItemServiceClient interface {
	// Lists all products for a given store with brief details
	ListProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*StoreItemList, error)
	// Retrieves more detailed information about the product
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*StoreItem, error)
}

type inventoryItemServiceClient struct {
	cc *grpc.ClientConn
}

func NewInventoryItemServiceClient(cc *grpc.ClientConn) InventoryItemServiceClient {
	return &inventoryItemServiceClient{cc}
}

func (c *inventoryItemServiceClient) ListProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*StoreItemList, error) {
	out := new(StoreItemList)
	err := c.cc.Invoke(ctx, "/client.v1.InventoryItemService/ListProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryItemServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*StoreItem, error) {
	out := new(StoreItem)
	err := c.cc.Invoke(ctx, "/client.v1.InventoryItemService/GetProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryItemServiceServer is the server API for InventoryItemService service.
type InventoryItemServiceServer interface {
	// Lists all products for a given store with brief details
	ListProducts(context.Context, *ProductFilter) (*StoreItemList, error)
	// Retrieves more detailed information about the product
	GetProduct(context.Context, *GetProductRequest) (*StoreItem, error)
}

// UnimplementedInventoryItemServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInventoryItemServiceServer struct {
}

func (*UnimplementedInventoryItemServiceServer) ListProducts(ctx context.Context, req *ProductFilter) (*StoreItemList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProducts not implemented")
}
func (*UnimplementedInventoryItemServiceServer) GetProduct(ctx context.Context, req *GetProductRequest) (*StoreItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}

func RegisterInventoryItemServiceServer(s *grpc.Server, srv InventoryItemServiceServer) {
	s.RegisterService(&_InventoryItemService_serviceDesc, srv)
}

func _InventoryItemService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryItemServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.InventoryItemService/ListProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryItemServiceServer).ListProducts(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryItemService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryItemServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.InventoryItemService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryItemServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InventoryItemService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.InventoryItemService",
	HandlerType: (*InventoryItemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProducts",
			Handler:    _InventoryItemService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _InventoryItemService_GetProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderServiceClient interface {
	// GetActiveOrder returns the current order that the client has active.
	// In case there's no active order, an empty order is returned
	GetActiveOrder(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Order, error)
	// AddItemToOrder adds an item to the currently active order
	AddItemToOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error)
	// RemoveItemFromOrder removes an item from the currently active order
	RemoveItemFromOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error)
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// ListOrders returns all orders that the client has access to
	ListOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) GetActiveOrder(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/GetActiveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) AddItemToOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/AddItemToOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) RemoveItemFromOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/RemoveItemFromOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/SubmitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ListOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error) {
	out := new(OrderList)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
type OrderServiceServer interface {
	// GetActiveOrder returns the current order that the client has active.
	// In case there's no active order, an empty order is returned
	GetActiveOrder(context.Context, *empty.Empty) (*Order, error)
	// AddItemToOrder adds an item to the currently active order
	AddItemToOrder(context.Context, *OrderItem) (*Order, error)
	// RemoveItemFromOrder removes an item from the currently active order
	RemoveItemFromOrder(context.Context, *OrderItem) (*Order, error)
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(context.Context, *Order) (*Order, error)
	// ListOrders returns all orders that the client has access to
	ListOrders(context.Context, *OrderFilter) (*OrderList, error)
}

// UnimplementedOrderServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOrderServiceServer struct {
}

func (*UnimplementedOrderServiceServer) GetActiveOrder(ctx context.Context, req *empty.Empty) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveOrder not implemented")
}
func (*UnimplementedOrderServiceServer) AddItemToOrder(ctx context.Context, req *OrderItem) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItemToOrder not implemented")
}
func (*UnimplementedOrderServiceServer) RemoveItemFromOrder(ctx context.Context, req *OrderItem) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveItemFromOrder not implemented")
}
func (*UnimplementedOrderServiceServer) SubmitOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitOrder not implemented")
}
func (*UnimplementedOrderServiceServer) ListOrders(ctx context.Context, req *OrderFilter) (*OrderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_GetActiveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetActiveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/GetActiveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetActiveOrder(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_AddItemToOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).AddItemToOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/AddItemToOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).AddItemToOrder(ctx, req.(*OrderItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_RemoveItemFromOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).RemoveItemFromOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/RemoveItemFromOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).RemoveItemFromOrder(ctx, req.(*OrderItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_SubmitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SubmitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/SubmitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SubmitOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ListOrders(ctx, req.(*OrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActiveOrder",
			Handler:    _OrderService_GetActiveOrder_Handler,
		},
		{
			MethodName: "AddItemToOrder",
			Handler:    _OrderService_AddItemToOrder_Handler,
		},
		{
			MethodName: "RemoveItemFromOrder",
			Handler:    _OrderService_RemoveItemFromOrder_Handler,
		},
		{
			MethodName: "SubmitOrder",
			Handler:    _OrderService_SubmitOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _OrderService_ListOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

func (m *EmailPassword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmailPassword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmailPassword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Customer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CustomerId) > 0 {
		i -= len(m.CustomerId)
		copy(dAtA[i:], m.CustomerId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.CustomerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Store) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Store) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Store) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClientApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Count != 0 {
		i = encodeVarintClientApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x58
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClientApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClientApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StoreItemId) > 0 {
		i -= len(m.StoreItemId)
		copy(dAtA[i:], m.StoreItemId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreItemId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClientApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClientApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClientApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClientApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClientApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClientApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Images) > 0 {
		for iNdEx := len(m.Images) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Images[iNdEx])
			copy(dAtA[i:], m.Images[iNdEx])
			i = encodeVarintClientApi(dAtA, i, uint64(len(m.Images[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetProductRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProductRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetProductRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		for k := range m.Filter {
			v := m.Filter[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintClientApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClientApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClientApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerchantId) > 0 {
		i -= len(m.MerchantId)
		copy(dAtA[i:], m.MerchantId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.MerchantId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreItemList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreItemList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreItemList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Count != 0 {
		i = encodeVarintClientApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClientApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintClientApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovClientApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmailPassword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *Customer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *Store) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *GetStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *StoreItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.StoreItemId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovClientApi(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovClientApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovClientApi(uint64(m.Count))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 2 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClientApi(uint64(len(k))) + 1 + len(v) + sovClientApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovClientApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClientApi(uint64(len(k))) + 1 + len(v) + sovClientApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovClientApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetProductRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *ProductFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MerchantId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if len(m.Filter) > 0 {
		for k, v := range m.Filter {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovClientApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovClientApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovClientApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StoreItemList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *OrderItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovClientApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovClientApi(uint64(m.Count))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *OrderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	return n
}

func (m *OrderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func sovClientApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClientApi(x uint64) (n int) {
	return sovClientApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EmailPassword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailPassword{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Customer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Customer{`,
		`CustomerId:` + fmt.Sprintf("%v", this.CustomerId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Thumbnail:` + fmt.Sprintf("%v", this.Thumbnail) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Store) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Store{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetStoreRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetStoreRequest{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreItem{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreItemId:` + fmt.Sprintf("%v", this.StoreItemId) + `,`,
		`InventoryId:` + fmt.Sprintf("%v", this.InventoryId) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "Amount", "v1.Amount", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&Product{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Images:` + fmt.Sprintf("%v", this.Images) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetProductRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetProductRequest{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductFilter) String() string {
	if this == nil {
		return "nil"
	}
	keysForFilter := make([]string, 0, len(this.Filter))
	for k, _ := range this.Filter {
		keysForFilter = append(keysForFilter, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFilter)
	mapStringForFilter := "map[string]*v1.ExpressionList{"
	for _, k := range keysForFilter {
		mapStringForFilter += fmt.Sprintf("%v: %v,", k, this.Filter[k])
	}
	mapStringForFilter += "}"
	s := strings.Join([]string{`&ProductFilter{`,
		`MerchantId:` + fmt.Sprintf("%v", this.MerchantId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`Filter:` + mapStringForFilter + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreItemList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*StoreItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "StoreItem", "StoreItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&StoreItemList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*OrderItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "OrderItem", "OrderItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&Order{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderItem{`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Order{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Order", "Order", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&OrderList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderFilter{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClientApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EmailPassword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &v1.Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProductRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProductRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProductRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerchantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerchantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = make(map[string]*v1.ExpressionList)
			}
			var mapkey string
			var mapvalue *v1.ExpressionList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthClientApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthClientApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &v1.ExpressionList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Filter[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreItemList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreItemList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreItemList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &StoreItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &OrderItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Order{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClientApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClientApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClientApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClientApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClientApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClientApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClientApi = fmt.Errorf("proto: unexpected end of group")
)
