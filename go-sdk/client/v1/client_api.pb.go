// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/client_api.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EmailPassword struct {
	Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *EmailPassword) Reset()      { *m = EmailPassword{} }
func (*EmailPassword) ProtoMessage() {}
func (*EmailPassword) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{0}
}
func (m *EmailPassword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmailPassword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmailPassword.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmailPassword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmailPassword.Merge(m, src)
}
func (m *EmailPassword) XXX_Size() int {
	return m.Size()
}
func (m *EmailPassword) XXX_DiscardUnknown() {
	xxx_messageInfo_EmailPassword.DiscardUnknown(m)
}

var xxx_messageInfo_EmailPassword proto.InternalMessageInfo

func (m *EmailPassword) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *EmailPassword) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Customer struct {
	CustomerId string `protobuf:"bytes,1,opt,name=customerId,proto3" json:"customerId,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Thumbnail  string `protobuf:"bytes,3,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *Customer) Reset()      { *m = Customer{} }
func (*Customer) ProtoMessage() {}
func (*Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{1}
}
func (m *Customer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Customer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Customer.Merge(m, src)
}
func (m *Customer) XXX_Size() int {
	return m.Size()
}
func (m *Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Customer proto.InternalMessageInfo

func (m *Customer) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *Customer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Customer) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

type Product struct {
	ProductId string            `protobuf:"bytes,1,opt,name=productId,proto3" json:"productId,omitempty"`
	Name      string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	StoreId   string            `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
	Labels    map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// attributes are custom key-value pairs provided for the product
	Attributes map[string]string `protobuf:"bytes,100,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{2}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func (m *Product) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Product) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type ProductFilter struct {
	ProductId string `protobuf:"bytes,1,opt,name=productId,proto3" json:"productId,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ProductFilter) Reset()      { *m = ProductFilter{} }
func (*ProductFilter) ProtoMessage() {}
func (*ProductFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{3}
}
func (m *ProductFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductFilter.Merge(m, src)
}
func (m *ProductFilter) XXX_Size() int {
	return m.Size()
}
func (m *ProductFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ProductFilter proto.InternalMessageInfo

func (m *ProductFilter) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *ProductFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ProductList struct {
	Data []*Product `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *ProductList) Reset()      { *m = ProductList{} }
func (*ProductList) ProtoMessage() {}
func (*ProductList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{4}
}
func (m *ProductList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductList.Merge(m, src)
}
func (m *ProductList) XXX_Size() int {
	return m.Size()
}
func (m *ProductList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductList.DiscardUnknown(m)
}

var xxx_messageInfo_ProductList proto.InternalMessageInfo

func (m *ProductList) GetData() []*Product {
	if m != nil {
		return m.Data
	}
	return nil
}

type Order struct {
	OrderId string       `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	Items   []*OrderItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	Status  string       `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{5}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetItems() []*OrderItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Order) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type OrderItem struct {
	Product *Product `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	Count   int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	OrderId string   `protobuf:"bytes,10,opt,name=orderId,proto3" json:"orderId,omitempty"`
}

func (m *OrderItem) Reset()      { *m = OrderItem{} }
func (*OrderItem) ProtoMessage() {}
func (*OrderItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{6}
}
func (m *OrderItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderItem.Merge(m, src)
}
func (m *OrderItem) XXX_Size() int {
	return m.Size()
}
func (m *OrderItem) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderItem.DiscardUnknown(m)
}

var xxx_messageInfo_OrderItem proto.InternalMessageInfo

func (m *OrderItem) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OrderItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *OrderItem) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type OrderList struct {
	Items []*Order `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *OrderList) Reset()      { *m = OrderList{} }
func (*OrderList) ProtoMessage() {}
func (*OrderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{7}
}
func (m *OrderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderList.Merge(m, src)
}
func (m *OrderList) XXX_Size() int {
	return m.Size()
}
func (m *OrderList) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderList.DiscardUnknown(m)
}

var xxx_messageInfo_OrderList proto.InternalMessageInfo

func (m *OrderList) GetItems() []*Order {
	if m != nil {
		return m.Items
	}
	return nil
}

type OrderFilter struct {
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
}

func (m *OrderFilter) Reset()      { *m = OrderFilter{} }
func (*OrderFilter) ProtoMessage() {}
func (*OrderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b71fc9c9ecb49eb, []int{8}
}
func (m *OrderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilter.Merge(m, src)
}
func (m *OrderFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilter proto.InternalMessageInfo

func (m *OrderFilter) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func init() {
	proto.RegisterType((*EmailPassword)(nil), "client.v1.EmailPassword")
	proto.RegisterType((*Customer)(nil), "client.v1.Customer")
	proto.RegisterType((*Product)(nil), "client.v1.Product")
	proto.RegisterMapType((map[string]string)(nil), "client.v1.Product.AttributesEntry")
	proto.RegisterMapType((map[string]string)(nil), "client.v1.Product.LabelsEntry")
	proto.RegisterType((*ProductFilter)(nil), "client.v1.ProductFilter")
	proto.RegisterType((*ProductList)(nil), "client.v1.ProductList")
	proto.RegisterType((*Order)(nil), "client.v1.Order")
	proto.RegisterType((*OrderItem)(nil), "client.v1.OrderItem")
	proto.RegisterType((*OrderList)(nil), "client.v1.OrderList")
	proto.RegisterType((*OrderFilter)(nil), "client.v1.OrderFilter")
}

func init() { proto.RegisterFile("v1/client_api.proto", fileDescriptor_7b71fc9c9ecb49eb) }

var fileDescriptor_7b71fc9c9ecb49eb = []byte{
	// 874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x95, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xbd, 0x4e, 0x93, 0xd4, 0xcf, 0x21, 0x35, 0x93, 0xd4, 0xac, 0x9c, 0x32, 0x8a, 0x06,
	0xa9, 0x94, 0x00, 0xbb, 0x4a, 0x2a, 0x10, 0x58, 0xe2, 0xe0, 0xa2, 0xb4, 0xb2, 0xa8, 0x44, 0xe5,
	0x50, 0x21, 0x10, 0x12, 0x1d, 0x7b, 0xa7, 0xf6, 0xa8, 0xbb, 0x3b, 0xab, 0x9d, 0xd9, 0xad, 0xa2,
	0xaa, 0x12, 0xe2, 0x13, 0x20, 0xf1, 0x25, 0xf8, 0x1c, 0x3d, 0x21, 0x71, 0x09, 0xe2, 0xd2, 0x23,
	0x71, 0x38, 0x70, 0xec, 0x47, 0x40, 0x33, 0x3b, 0xbb, 0xb5, 0x63, 0x07, 0x29, 0x87, 0xde, 0xe6,
	0xcd, 0xbc, 0xf7, 0xfb, 0xbf, 0x79, 0xef, 0xcd, 0x2e, 0x6c, 0xe5, 0xfb, 0xfe, 0x28, 0xe4, 0x2c,
	0x56, 0x3f, 0xd2, 0x84, 0x7b, 0x49, 0x2a, 0x94, 0x40, 0x8d, 0x62, 0xc7, 0xcb, 0xf7, 0x3b, 0x37,
	0xc6, 0x42, 0x8c, 0x43, 0xe6, 0xd3, 0x84, 0xfb, 0x34, 0x8e, 0x85, 0xa2, 0x8a, 0x8b, 0x58, 0x16,
	0x8e, 0x9d, 0x1d, 0x7b, 0x6a, 0xac, 0x61, 0xf6, 0xd8, 0x67, 0x51, 0xa2, 0x8e, 0x8b, 0x43, 0xd2,
	0x83, 0xb7, 0x0e, 0x23, 0xca, 0xc3, 0x07, 0x54, 0xca, 0xa7, 0x22, 0x0d, 0xd0, 0x36, 0xac, 0x32,
	0xbd, 0xe1, 0x3a, 0xbb, 0xce, 0xad, 0xc6, 0xa0, 0x30, 0x50, 0x07, 0xae, 0x26, 0xd6, 0xc3, 0xad,
	0x9b, 0x83, 0xca, 0x26, 0x3f, 0xc0, 0xd5, 0x2f, 0x33, 0xa9, 0x44, 0xc4, 0x52, 0x84, 0x01, 0x46,
	0x76, 0xdd, 0x0f, 0x2c, 0x62, 0x66, 0x07, 0x21, 0xb8, 0x12, 0xd3, 0x88, 0x59, 0x86, 0x59, 0xa3,
	0x1b, 0xd0, 0x50, 0x93, 0x2c, 0x1a, 0xc6, 0x5a, 0x75, 0xc5, 0x1c, 0xbc, 0xde, 0x20, 0x7f, 0xd4,
	0x61, 0xfd, 0x41, 0x2a, 0x82, 0x6c, 0xa4, 0xb4, 0x67, 0x52, 0x2c, 0x2b, 0xf8, 0xeb, 0x8d, 0xa5,
	0x6c, 0x17, 0xd6, 0xa5, 0x12, 0x29, 0xeb, 0x07, 0x6e, 0xd3, 0x6c, 0x97, 0x26, 0xfa, 0x14, 0xd6,
	0x42, 0x3a, 0x64, 0xa1, 0x74, 0xb7, 0x77, 0x57, 0x6e, 0x35, 0x0f, 0xb0, 0x57, 0xd5, 0xd3, 0xb3,
	0x7a, 0xde, 0x7d, 0xe3, 0x70, 0x18, 0xab, 0xf4, 0x78, 0x60, 0xbd, 0xd1, 0x1d, 0x00, 0xaa, 0x54,
	0xca, 0x87, 0x99, 0x62, 0xd2, 0x0d, 0x4c, 0x2c, 0x59, 0x12, 0xdb, 0xab, 0x9c, 0x8a, 0xf8, 0x99,
	0xa8, 0xce, 0xe7, 0xd0, 0x9c, 0x41, 0xa3, 0x16, 0xac, 0x3c, 0x61, 0xc7, 0xf6, 0x42, 0x7a, 0xa9,
	0x9b, 0x90, 0xd3, 0x30, 0x2b, 0xef, 0x52, 0x18, 0xdd, 0xfa, 0x67, 0x4e, 0xe7, 0x0b, 0xb8, 0x76,
	0x8e, 0x7c, 0x99, 0x70, 0xdd, 0x6e, 0x9b, 0xe0, 0x5d, 0x1e, 0x2a, 0x96, 0x5e, 0xbe, 0xa4, 0xe4,
	0x13, 0x68, 0x5a, 0xc4, 0x7d, 0x2e, 0x15, 0xba, 0x09, 0x57, 0x02, 0xaa, 0xa8, 0xeb, 0x98, 0x4a,
	0xa0, 0xc5, 0x4a, 0x0c, 0xcc, 0x39, 0x61, 0xb0, 0xfa, 0x75, 0x1a, 0xb0, 0x54, 0xb7, 0x44, 0xe8,
	0x45, 0xa5, 0x57, 0x9a, 0x68, 0x0f, 0x56, 0xb9, 0x62, 0x91, 0x74, 0xeb, 0x86, 0xb5, 0x3d, 0xc3,
	0x32, 0xa1, 0x7d, 0xc5, 0xa2, 0x41, 0xe1, 0x82, 0xda, 0xb0, 0x26, 0x15, 0x55, 0x99, 0xb4, 0x13,
	0x63, 0x2d, 0xc2, 0xa1, 0x51, 0xf9, 0xa2, 0x8f, 0x60, 0xdd, 0xde, 0xc5, 0x48, 0x2d, 0x4f, 0xaf,
	0x74, 0xd1, 0x55, 0x1b, 0x89, 0x2c, 0x56, 0xe6, 0xb6, 0xab, 0x83, 0xc2, 0x98, 0x4d, 0x17, 0xe6,
	0xd2, 0x25, 0xb7, 0xad, 0x94, 0x2d, 0x83, 0xcd, 0xbd, 0xa8, 0x43, 0xeb, 0x7c, 0xee, 0x36, 0x6f,
	0xf2, 0x3e, 0x34, 0x8d, 0x6d, 0xcb, 0x7f, 0x61, 0x31, 0x0e, 0xfe, 0x74, 0xa0, 0xd9, 0xcb, 0xd4,
	0xe4, 0x88, 0xa5, 0x39, 0x1f, 0x31, 0xf4, 0x08, 0xd0, 0x11, 0x1f, 0xc7, 0xfd, 0xf8, 0x5b, 0xae,
	0x26, 0xd5, 0x6b, 0x75, 0x67, 0x74, 0xe6, 0xde, 0x71, 0x67, 0x6b, 0xe6, 0xa4, 0x7c, 0x9e, 0x64,
	0xe7, 0xe7, 0xbf, 0xfe, 0xf9, 0xb5, 0x7e, 0x9d, 0xb4, 0x7c, 0x3a, 0x32, 0xd7, 0x93, 0x5d, 0x69,
	0xa0, 0x5d, 0x67, 0xaf, 0x54, 0x78, 0x98, 0xbc, 0x01, 0x85, 0x87, 0x49, 0xd7, 0xd9, 0x3b, 0x78,
	0xe1, 0x40, 0xab, 0x1f, 0xe7, 0x2c, 0x56, 0x22, 0x3d, 0x2e, 0x2f, 0x76, 0x04, 0x1b, 0xba, 0x82,
	0xb6, 0x1d, 0x72, 0x4e, 0x70, 0x6e, 0x56, 0x3b, 0xed, 0xc5, 0x13, 0x1d, 0x49, 0xde, 0x36, 0x9a,
	0x4d, 0xd4, 0xf0, 0x93, 0x12, 0xf2, 0x1d, 0xc0, 0x3d, 0x56, 0x32, 0xff, 0x07, 0xb9, 0x64, 0x20,
	0xc8, 0xbb, 0x06, 0xf7, 0x0e, 0xba, 0x5e, 0xe1, 0xfc, 0x67, 0xd5, 0x93, 0x78, 0x7e, 0xf0, 0x62,
	0x05, 0x36, 0x4c, 0x0b, 0xcb, 0x0b, 0x0c, 0x60, 0xf3, 0x1e, 0x53, 0xbd, 0x91, 0xe2, 0x39, 0x2b,
	0x46, 0xbc, 0xed, 0x15, 0x9f, 0x5c, 0xaf, 0xfc, 0xe4, 0x7a, 0x87, 0xfa, 0x93, 0xdb, 0x59, 0x98,
	0x0a, 0xd2, 0x36, 0x5a, 0x2d, 0xb4, 0xe9, 0x9b, 0xbe, 0xcb, 0x2e, 0x35, 0x18, 0xf4, 0x08, 0x36,
	0x7b, 0x41, 0xa0, 0x87, 0xf8, 0x1b, 0x51, 0x30, 0x97, 0xbe, 0x86, 0x25, 0xc4, 0x9b, 0x86, 0xb8,
	0x4b, 0x76, 0x2c, 0xd1, 0x7f, 0x66, 0x27, 0xea, 0xb9, 0x6f, 0x26, 0xb0, 0x4b, 0x83, 0x40, 0x77,
	0x7b, 0x02, 0x5b, 0x03, 0x16, 0x89, 0x9c, 0x69, 0xce, 0xdd, 0x54, 0x44, 0x97, 0x93, 0xf9, 0xc0,
	0xc8, 0xbc, 0x47, 0xf0, 0x45, 0x32, 0xa9, 0x81, 0x6b, 0xa5, 0x43, 0x68, 0x1e, 0x65, 0xc3, 0x88,
	0xab, 0x42, 0x61, 0x81, 0xb5, 0x84, 0x8e, 0x0c, 0x7d, 0x83, 0xac, 0x97, 0x65, 0x71, 0xf6, 0xd0,
	0x57, 0x00, 0xba, 0xdb, 0xc6, 0x41, 0xa2, 0xf6, 0xf9, 0x18, 0xdb, 0xd0, 0x85, 0xfc, 0xcd, 0x84,
	0x5c, 0x33, 0xbc, 0x06, 0x2a, 0x79, 0x77, 0xe8, 0xc9, 0x29, 0xae, 0xbd, 0x3c, 0xc5, 0xb5, 0x57,
	0xa7, 0xd8, 0xf9, 0x69, 0x8a, 0x9d, 0xdf, 0xa6, 0xd8, 0xf9, 0x7d, 0x8a, 0x9d, 0x93, 0x29, 0x76,
	0xfe, 0x9e, 0x62, 0xe7, 0xdf, 0x29, 0xae, 0xbd, 0x9a, 0x62, 0xe7, 0x97, 0x33, 0x5c, 0x3b, 0x39,
	0xc3, 0xb5, 0x97, 0x67, 0xb8, 0xf6, 0xfd, 0x87, 0x63, 0xae, 0x26, 0xd9, 0xd0, 0x1b, 0x89, 0xc8,
	0x7f, 0x1c, 0x8a, 0xa7, 0x59, 0xe2, 0x4f, 0x18, 0x0d, 0x42, 0x26, 0xa5, 0x3f, 0x16, 0x1f, 0xcb,
	0xe0, 0x89, 0xfd, 0x4d, 0xfb, 0xf9, 0xfe, 0x70, 0xcd, 0x34, 0xff, 0xf6, 0x7f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x75, 0x3e, 0xa5, 0x0c, 0xbd, 0x07, 0x00, 0x00,
}

func (this *EmailPassword) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmailPassword)
	if !ok {
		that2, ok := that.(EmailPassword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	return true
}
func (this *Customer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Customer)
	if !ok {
		that2, ok := that.(Customer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Thumbnail != that1.Thumbnail {
		return false
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if this.Attributes[i] != that1.Attributes[i] {
			return false
		}
	}
	return true
}
func (this *ProductFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductFilter)
	if !ok {
		that2, ok := that.(ProductFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ProductList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductList)
	if !ok {
		that2, ok := that.(ProductList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *OrderItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderItem)
	if !ok {
		that2, ok := that.(OrderItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *OrderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderList)
	if !ok {
		that2, ok := that.(OrderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *OrderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderFilter)
	if !ok {
		that2, ok := that.(OrderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	return true
}
func (this *EmailPassword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.EmailPassword{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Customer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.Customer{")
	s = append(s, "CustomerId: "+fmt.Sprintf("%#v", this.CustomerId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&v1.Product{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%#v: %#v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	if this.Attributes != nil {
		s = append(s, "Attributes: "+mapStringForAttributes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1.ProductFilter{")
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.ProductList{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.Order{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&v1.OrderItem{")
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderList{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1.OrderFilter{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClientApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	SignInWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error)
	SignUpWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) SignInWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/client.v1.AuthService/SignInWithPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SignUpWithPassword(ctx context.Context, in *EmailPassword, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := c.cc.Invoke(ctx, "/client.v1.AuthService/SignUpWithPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	SignInWithPassword(context.Context, *EmailPassword) (*Customer, error)
	SignUpWithPassword(context.Context, *EmailPassword) (*Customer, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) SignInWithPassword(ctx context.Context, req *EmailPassword) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInWithPassword not implemented")
}
func (*UnimplementedAuthServiceServer) SignUpWithPassword(ctx context.Context, req *EmailPassword) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpWithPassword not implemented")
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_SignInWithPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SignInWithPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.AuthService/SignInWithPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SignInWithPassword(ctx, req.(*EmailPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SignUpWithPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SignUpWithPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.AuthService/SignUpWithPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SignUpWithPassword(ctx, req.(*EmailPassword))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignInWithPassword",
			Handler:    _AuthService_SignInWithPassword_Handler,
		},
		{
			MethodName: "SignUpWithPassword",
			Handler:    _AuthService_SignUpWithPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

// InventoryServiceClient is the client API for InventoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InventoryServiceClient interface {
	ListProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductList, error)
	GetProduct(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*Product, error)
}

type inventoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewInventoryServiceClient(cc *grpc.ClientConn) InventoryServiceClient {
	return &inventoryServiceClient{cc}
}

func (c *inventoryServiceClient) ListProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductList, error) {
	out := new(ProductList)
	err := c.cc.Invoke(ctx, "/client.v1.InventoryService/ListProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) GetProduct(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, "/client.v1.InventoryService/GetProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServiceServer is the server API for InventoryService service.
type InventoryServiceServer interface {
	ListProducts(context.Context, *ProductFilter) (*ProductList, error)
	GetProduct(context.Context, *ProductFilter) (*Product, error)
}

// UnimplementedInventoryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInventoryServiceServer struct {
}

func (*UnimplementedInventoryServiceServer) ListProducts(ctx context.Context, req *ProductFilter) (*ProductList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProducts not implemented")
}
func (*UnimplementedInventoryServiceServer) GetProduct(ctx context.Context, req *ProductFilter) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}

func RegisterInventoryServiceServer(s *grpc.Server, srv InventoryServiceServer) {
	s.RegisterService(&_InventoryService_serviceDesc, srv)
}

func _InventoryService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.InventoryService/ListProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).ListProducts(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.InventoryService/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).GetProduct(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _InventoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.InventoryService",
	HandlerType: (*InventoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProducts",
			Handler:    _InventoryService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _InventoryService_GetProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderServiceClient interface {
	// GetActiveOrder returns the current order that the client has active.
	// In case there's no active order, an empty order is returned
	GetActiveOrder(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Order, error)
	// AddItemToOrder adds an item to the currently active order
	AddItemToOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error)
	// RemoveItemFromOrder removes an item from the currently active order
	RemoveItemFromOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error)
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// ListOrders returns all orders that the client has access to
	ListOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) GetActiveOrder(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/GetActiveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) AddItemToOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/AddItemToOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) RemoveItemFromOrder(ctx context.Context, in *OrderItem, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/RemoveItemFromOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/SubmitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ListOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error) {
	out := new(OrderList)
	err := c.cc.Invoke(ctx, "/client.v1.OrderService/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
type OrderServiceServer interface {
	// GetActiveOrder returns the current order that the client has active.
	// In case there's no active order, an empty order is returned
	GetActiveOrder(context.Context, *empty.Empty) (*Order, error)
	// AddItemToOrder adds an item to the currently active order
	AddItemToOrder(context.Context, *OrderItem) (*Order, error)
	// RemoveItemFromOrder removes an item from the currently active order
	RemoveItemFromOrder(context.Context, *OrderItem) (*Order, error)
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(context.Context, *Order) (*Order, error)
	// ListOrders returns all orders that the client has access to
	ListOrders(context.Context, *OrderFilter) (*OrderList, error)
}

// UnimplementedOrderServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOrderServiceServer struct {
}

func (*UnimplementedOrderServiceServer) GetActiveOrder(ctx context.Context, req *empty.Empty) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveOrder not implemented")
}
func (*UnimplementedOrderServiceServer) AddItemToOrder(ctx context.Context, req *OrderItem) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddItemToOrder not implemented")
}
func (*UnimplementedOrderServiceServer) RemoveItemFromOrder(ctx context.Context, req *OrderItem) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveItemFromOrder not implemented")
}
func (*UnimplementedOrderServiceServer) SubmitOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitOrder not implemented")
}
func (*UnimplementedOrderServiceServer) ListOrders(ctx context.Context, req *OrderFilter) (*OrderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_GetActiveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetActiveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/GetActiveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetActiveOrder(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_AddItemToOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).AddItemToOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/AddItemToOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).AddItemToOrder(ctx, req.(*OrderItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_RemoveItemFromOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).RemoveItemFromOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/RemoveItemFromOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).RemoveItemFromOrder(ctx, req.(*OrderItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_SubmitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SubmitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/SubmitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SubmitOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.v1.OrderService/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ListOrders(ctx, req.(*OrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.v1.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActiveOrder",
			Handler:    _OrderService_GetActiveOrder_Handler,
		},
		{
			MethodName: "AddItemToOrder",
			Handler:    _OrderService_AddItemToOrder_Handler,
		},
		{
			MethodName: "RemoveItemFromOrder",
			Handler:    _OrderService_RemoveItemFromOrder_Handler,
		},
		{
			MethodName: "SubmitOrder",
			Handler:    _OrderService_SubmitOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _OrderService_ListOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/client_api.proto",
}

func (m *EmailPassword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmailPassword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmailPassword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Customer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Customer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CustomerId) > 0 {
		i -= len(m.CustomerId)
		copy(dAtA[i:], m.CustomerId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.CustomerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClientApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClientApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClientApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClientApi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClientApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClientApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Count != 0 {
		i = encodeVarintClientApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClientApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClientApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintClientApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintClientApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovClientApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EmailPassword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *Customer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClientApi(uint64(len(k))) + 1 + len(v) + sovClientApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovClientApi(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClientApi(uint64(len(k))) + 1 + len(v) + sovClientApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovClientApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProductFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *ProductList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *OrderItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovClientApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovClientApi(uint64(m.Count))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func (m *OrderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovClientApi(uint64(l))
		}
	}
	return n
}

func (m *OrderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovClientApi(uint64(l))
	}
	return n
}

func sovClientApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClientApi(x uint64) (n int) {
	return sovClientApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EmailPassword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmailPassword{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Customer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Customer{`,
		`CustomerId:` + fmt.Sprintf("%v", this.CustomerId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Thumbnail:` + fmt.Sprintf("%v", this.Thumbnail) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAttributes := make([]string, 0, len(this.Attributes))
	for k, _ := range this.Attributes {
		keysForAttributes = append(keysForAttributes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttributes)
	mapStringForAttributes := "map[string]string{"
	for _, k := range keysForAttributes {
		mapStringForAttributes += fmt.Sprintf("%v: %v,", k, this.Attributes[k])
	}
	mapStringForAttributes += "}"
	s := strings.Join([]string{`&Product{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Attributes:` + mapStringForAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProductFilter{`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*Product{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "Product", "Product", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&ProductList{`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*OrderItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "OrderItem", "OrderItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&Order{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderItem{`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Order{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Order", "Order", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&OrderList{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderFilter{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClientApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EmailPassword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClientApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Product{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &OrderItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Order{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClientApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthClientApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClientApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClientApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClientApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClientApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClientApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClientApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClientApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClientApi = fmt.Errorf("proto: unexpected end of group")
)
