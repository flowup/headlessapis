// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/user_api.proto

package headless

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Product struct {
	StoreId string `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{0}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type ProductFilter struct {
	StoreId string `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *ProductFilter) Reset()      { *m = ProductFilter{} }
func (*ProductFilter) ProtoMessage() {}
func (*ProductFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{1}
}
func (m *ProductFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductFilter.Merge(m, src)
}
func (m *ProductFilter) XXX_Size() int {
	return m.Size()
}
func (m *ProductFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ProductFilter proto.InternalMessageInfo

func (m *ProductFilter) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type ProductList struct {
}

func (m *ProductList) Reset()      { *m = ProductList{} }
func (*ProductList) ProtoMessage() {}
func (*ProductList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{2}
}
func (m *ProductList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductList.Merge(m, src)
}
func (m *ProductList) XXX_Size() int {
	return m.Size()
}
func (m *ProductList) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductList.DiscardUnknown(m)
}

var xxx_messageInfo_ProductList proto.InternalMessageInfo

type Order struct {
	OrderId   string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	CompanyId string `protobuf:"bytes,10,opt,name=companyId,proto3" json:"companyId,omitempty"`
	StoreId   string `protobuf:"bytes,2,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{3}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetCompanyId() string {
	if m != nil {
		return m.CompanyId
	}
	return ""
}

func (m *Order) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

type OrderList struct {
}

func (m *OrderList) Reset()      { *m = OrderList{} }
func (*OrderList) ProtoMessage() {}
func (*OrderList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{4}
}
func (m *OrderList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderList.Merge(m, src)
}
func (m *OrderList) XXX_Size() int {
	return m.Size()
}
func (m *OrderList) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderList.DiscardUnknown(m)
}

var xxx_messageInfo_OrderList proto.InternalMessageInfo

type OrderFilter struct {
	OrderId   string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	CompanyId string `protobuf:"bytes,10,opt,name=companyId,proto3" json:"companyId,omitempty"`
	StoreId   string `protobuf:"bytes,11,opt,name=storeId,proto3" json:"storeId,omitempty"`
}

func (m *OrderFilter) Reset()      { *m = OrderFilter{} }
func (*OrderFilter) ProtoMessage() {}
func (*OrderFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6beeca62d8388557, []int{5}
}
func (m *OrderFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilter.Merge(m, src)
}
func (m *OrderFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilter proto.InternalMessageInfo

func (m *OrderFilter) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderFilter) GetCompanyId() string {
	if m != nil {
		return m.CompanyId
	}
	return ""
}

func (m *OrderFilter) GetStoreId() string {
	if m != nil {
		return m.StoreId
	}
	return ""
}

func init() {
	proto.RegisterType((*Product)(nil), "user.Product")
	proto.RegisterType((*ProductFilter)(nil), "user.ProductFilter")
	proto.RegisterType((*ProductList)(nil), "user.ProductList")
	proto.RegisterType((*Order)(nil), "user.Order")
	proto.RegisterType((*OrderList)(nil), "user.OrderList")
	proto.RegisterType((*OrderFilter)(nil), "user.OrderFilter")
}

func init() { proto.RegisterFile("v1/user_api.proto", fileDescriptor_6beeca62d8388557) }

var fileDescriptor_6beeca62d8388557 = []byte{
	// 440 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0x4f, 0x8b, 0xd3, 0x40,
	0x18, 0xc6, 0x33, 0x8b, 0xba, 0x64, 0xe2, 0xa2, 0x1d, 0x2f, 0x21, 0xd6, 0x51, 0x22, 0x82, 0x7a,
	0xc8, 0xe0, 0xee, 0x49, 0x8f, 0x1e, 0x5c, 0x02, 0x82, 0x8b, 0x0b, 0xc2, 0x7a, 0x29, 0xf9, 0x33,
	0x6d, 0x07, 0x92, 0x4c, 0x98, 0x99, 0x54, 0x8a, 0x14, 0xc4, 0x4f, 0x20, 0xf8, 0x25, 0xfc, 0x28,
	0xe2, 0xa9, 0xe0, 0xa5, 0x47, 0x9b, 0x7a, 0xf0, 0xd8, 0x8f, 0x20, 0x99, 0x49, 0x6d, 0x82, 0xe8,
	0x65, 0x6f, 0x79, 0xde, 0xf7, 0x9d, 0xe7, 0x37, 0xcf, 0x3b, 0x81, 0x83, 0xd9, 0x13, 0x52, 0x49,
	0x2a, 0x46, 0x51, 0xc9, 0x82, 0x52, 0x70, 0xc5, 0xd1, 0x95, 0x46, 0x7b, 0xc3, 0x09, 0xe7, 0x93,
	0x8c, 0x92, 0xa8, 0x64, 0x24, 0x2a, 0x0a, 0xae, 0x22, 0xc5, 0x78, 0x21, 0xcd, 0x8c, 0x77, 0xbb,
	0xed, 0x6a, 0x15, 0x57, 0x63, 0x42, 0xf3, 0x52, 0xcd, 0x4d, 0xd3, 0xbf, 0x0f, 0x0f, 0xcf, 0x04,
	0x4f, 0xab, 0x44, 0x21, 0x17, 0x1e, 0x4a, 0xc5, 0x05, 0x0d, 0x53, 0xd7, 0xb9, 0x07, 0x1e, 0xda,
	0xaf, 0x77, 0xd2, 0x7f, 0x04, 0x8f, 0xda, 0xa1, 0x17, 0x2c, 0x53, 0x54, 0xfc, 0x67, 0xf4, 0x08,
	0x3a, 0xed, 0xe8, 0x4b, 0x26, 0x95, 0x7f, 0x01, 0xaf, 0xbe, 0x12, 0xa9, 0x39, 0xc1, 0x9b, 0x8f,
	0x30, 0x75, 0x81, 0x39, 0xd1, 0x4a, 0x34, 0x84, 0x76, 0xc2, 0xf3, 0x32, 0x2a, 0xe6, 0x61, 0xea,
	0x42, 0xdd, 0xdb, 0x17, 0xba, 0xa4, 0x83, 0x3e, 0xc9, 0x81, 0xb6, 0xb6, 0xd6, 0x9c, 0x11, 0x74,
	0xb4, 0xd8, 0xdf, 0xef, 0xb2, 0xb4, 0x7e, 0xae, 0xe3, 0x1c, 0xde, 0x0c, 0x0b, 0x45, 0x0b, 0xc5,
	0xc5, 0xfc, 0x9c, 0x8a, 0x19, 0x4b, 0x28, 0xba, 0x80, 0xce, 0x29, 0x55, 0x6d, 0x5c, 0x89, 0x6e,
	0x05, 0xcd, 0x63, 0x04, 0xbd, 0x4d, 0x79, 0x83, 0x5e, 0x51, 0xdf, 0xd5, 0xff, 0xf8, 0xfd, 0xe7,
	0xe7, 0x83, 0x21, 0xf2, 0x88, 0x36, 0x97, 0xe4, 0x7d, 0x0b, 0x59, 0x34, 0x4f, 0xa4, 0xbd, 0x8e,
	0xbf, 0x01, 0x78, 0x5d, 0x07, 0xda, 0xb1, 0x62, 0xe8, 0x9c, 0x57, 0x71, 0xce, 0x94, 0x59, 0xa7,
	0x63, 0x6c, 0xb5, 0xf0, 0xba, 0xc2, 0x7f, 0xaa, 0xdd, 0x4f, 0xfc, 0x80, 0x98, 0x58, 0xac, 0x01,
	0xfc, 0x49, 0xb8, 0xf8, 0x9b, 0xa9, 0x37, 0x23, 0x9f, 0x81, 0xc7, 0xe8, 0x0d, 0xb4, 0x4f, 0xa9,
	0x01, 0x48, 0x34, 0xe8, 0x98, 0xb6, 0x59, 0x6e, 0x74, 0x4a, 0x3a, 0xc9, 0x03, 0xcd, 0xba, 0x8b,
	0xee, 0xfc, 0x83, 0x65, 0xac, 0x9f, 0x9f, 0x2d, 0xd7, 0xd8, 0x5a, 0xad, 0xb1, 0xb5, 0x5d, 0x63,
	0xf0, 0xa1, 0xc6, 0xe0, 0x4b, 0x8d, 0xc1, 0xd7, 0x1a, 0x83, 0x65, 0x8d, 0xc1, 0x8f, 0x1a, 0x83,
	0x5f, 0x35, 0xb6, 0xb6, 0x35, 0x06, 0x9f, 0x36, 0xd8, 0x5a, 0x6e, 0xb0, 0xb5, 0xda, 0x60, 0xeb,
	0xad, 0x37, 0x61, 0x6a, 0x5a, 0xc5, 0x41, 0xc2, 0x73, 0x32, 0xce, 0xf8, 0xbb, 0xaa, 0x24, 0x53,
	0x1a, 0xa5, 0x19, 0x95, 0x32, 0xbe, 0xa6, 0x7f, 0xde, 0x93, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x3d, 0x59, 0x66, 0x4e, 0x12, 0x03, 0x00, 0x00,
}

func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *ProductFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductFilter)
	if !ok {
		that2, ok := that.(ProductFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *ProductList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductList)
	if !ok {
		that2, ok := that.(ProductList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.CompanyId != that1.CompanyId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *OrderList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderList)
	if !ok {
		that2, ok := that.(OrderList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *OrderFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderFilter)
	if !ok {
		that2, ok := that.(OrderFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.CompanyId != that1.CompanyId {
		return false
	}
	if this.StoreId != that1.StoreId {
		return false
	}
	return true
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&headless.Product{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&headless.ProductFilter{")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&headless.ProductList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&headless.Order{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "CompanyId: "+fmt.Sprintf("%#v", this.CompanyId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&headless.OrderList{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&headless.OrderFilter{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "CompanyId: "+fmt.Sprintf("%#v", this.CompanyId)+",\n")
	s = append(s, "StoreId: "+fmt.Sprintf("%#v", this.StoreId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUserApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IntentoryServiceClient is the client API for IntentoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IntentoryServiceClient interface {
	GetProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductList, error)
}

type intentoryServiceClient struct {
	cc *grpc.ClientConn
}

func NewIntentoryServiceClient(cc *grpc.ClientConn) IntentoryServiceClient {
	return &intentoryServiceClient{cc}
}

func (c *intentoryServiceClient) GetProducts(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductList, error) {
	out := new(ProductList)
	err := c.cc.Invoke(ctx, "/user.IntentoryService/GetProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntentoryServiceServer is the server API for IntentoryService service.
type IntentoryServiceServer interface {
	GetProducts(context.Context, *ProductFilter) (*ProductList, error)
}

// UnimplementedIntentoryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedIntentoryServiceServer struct {
}

func (*UnimplementedIntentoryServiceServer) GetProducts(ctx context.Context, req *ProductFilter) (*ProductList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProducts not implemented")
}

func RegisterIntentoryServiceServer(s *grpc.Server, srv IntentoryServiceServer) {
	s.RegisterService(&_IntentoryService_serviceDesc, srv)
}

func _IntentoryService_GetProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntentoryServiceServer).GetProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.IntentoryService/GetProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntentoryServiceServer).GetProducts(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _IntentoryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "user.IntentoryService",
	HandlerType: (*IntentoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProducts",
			Handler:    _IntentoryService_GetProducts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/user_api.proto",
}

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderServiceClient interface {
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error)
}

type orderServiceClient struct {
	cc *grpc.ClientConn
}

func NewOrderServiceClient(cc *grpc.ClientConn) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) SubmitOrder(ctx context.Context, in *Order, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/user.OrderService/SubmitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrders(ctx context.Context, in *OrderFilter, opts ...grpc.CallOption) (*OrderList, error) {
	out := new(OrderList)
	err := c.cc.Invoke(ctx, "/user.OrderService/GetOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
type OrderServiceServer interface {
	// SubmitOrder submits the order to the system and creates it if it's possible,
	// otherwise returns errors why the creation failed
	SubmitOrder(context.Context, *Order) (*Order, error)
	// GetOrders returns all orders that the user has access to
	GetOrders(context.Context, *OrderFilter) (*OrderList, error)
}

// UnimplementedOrderServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOrderServiceServer struct {
}

func (*UnimplementedOrderServiceServer) SubmitOrder(ctx context.Context, req *Order) (*Order, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitOrder not implemented")
}
func (*UnimplementedOrderServiceServer) GetOrders(ctx context.Context, req *OrderFilter) (*OrderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrders not implemented")
}

func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) {
	s.RegisterService(&_OrderService_serviceDesc, srv)
}

func _OrderService_SubmitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Order)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SubmitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.OrderService/SubmitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SubmitOrder(ctx, req.(*Order))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.OrderService/GetOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrders(ctx, req.(*OrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "user.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitOrder",
			Handler:    _OrderService_SubmitOrder_Handler,
		},
		{
			MethodName: "GetOrders",
			Handler:    _OrderService_GetOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/user_api.proto",
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}

func (m *ProductFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}

func (m *ProductList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompanyId) > 0 {
		i -= len(m.CompanyId)
		copy(dAtA[i:], m.CompanyId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.CompanyId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OrderFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreId) > 0 {
		i -= len(m.StoreId)
		copy(dAtA[i:], m.StoreId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.StoreId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CompanyId) > 0 {
		i -= len(m.CompanyId)
		copy(dAtA[i:], m.CompanyId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.CompanyId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintUserApi(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintUserApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovUserApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	return n
}

func (m *ProductFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	return n
}

func (m *ProductList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	l = len(m.CompanyId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	return n
}

func (m *OrderList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OrderFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	l = len(m.CompanyId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	l = len(m.StoreId)
	if l > 0 {
		n += 1 + l + sovUserApi(uint64(l))
	}
	return n
}

func sovUserApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUserApi(x uint64) (n int) {
	return sovUserApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Product{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProductFilter{`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProductList{`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`CompanyId:` + fmt.Sprintf("%v", this.CompanyId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderList{`,
		`}`,
	}, "")
	return s
}
func (this *OrderFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderFilter{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`CompanyId:` + fmt.Sprintf("%v", this.CompanyId) + `,`,
		`StoreId:` + fmt.Sprintf("%v", this.StoreId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringUserApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUserApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUserApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUserApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUserApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUserApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUserApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUserApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUserApi = fmt.Errorf("proto: unexpected end of group")
)
